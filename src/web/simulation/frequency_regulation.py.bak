from __future__ import annotations

from typing import Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
import streamlit as st

from src.web.config import project_root
from src.web.utils import safe_pyplot_figure


@st.cache_data(show_spinner=False)
def simulate_frequency_regulation_revenue(
    prices_eur: pd.DataFrame,
    contracted_mw: float,
    capacity_price_eur_mw_h: float,
    up_threshold_eur_mwh: float = 0.0,
    down_threshold_eur_mwh: float = 0.0,
    pay_down_as_positive: bool = True,
) -> Dict:
    """Estimate revenue using estimated imbalance prices as proxy for activation price.
    - Capacity revenue = contracted_mw * hours_available_in_month * capacity_price_eur_mw_h
      where hours_available_in_month is computed from the presence of any price entries that month.
    - Activation revenue: when price >= up_threshold or price <= -down_threshold, assume full contracted MW activated.
    - Energy per 15-min slot = contracted_mw * 0.25 MWh.
    - If pay_down_as_positive=True, down-activation uses |price|; else uses signed price.
    """
    if prices_eur is None or prices_eur.empty or contracted_mw <= 0:
        return {
            'monthly': [],
            'totals': {
                'capacity_revenue_eur': 0.0,
                'activation_revenue_eur': 0.0,
                'total_revenue_eur': 0.0,
                'months': 0
            }
        }

    df = prices_eur.copy()
    df['date'] = pd.to_datetime(df['date'])
    df['month'] = df['date'].dt.to_period('M')

    monthly_rows = []
    cap_total = 0.0
    act_total = 0.0

    for month, mdf in df.groupby('month'):
        hours_in_data = len(mdf) * 0.25
        cap_rev = contracted_mw * hours_in_data * capacity_price_eur_mw_h
        # Activation flags
        up_mask = mdf['price_eur_mwh'] >= float(up_threshold_eur_mwh)
        down_mask = mdf['price_eur_mwh'] <= -float(down_threshold_eur_mwh)
        # Energy per slot
        energy_mwh_per_slot = contracted_mw * 0.25
        # Up activation revenue
        up_rev = float((mdf.loc[up_mask, 'price_eur_mwh'] * energy_mwh_per_slot).sum())
        # Down activation revenue (toggle absolute or signed)
        if pay_down_as_positive:
            down_rev = float((mdf.loc[down_mask, 'price_eur_mwh'].abs() * energy_mwh_per_slot).sum())
        else:
            down_rev = float((mdf.loc[down_mask, 'price_eur_mwh'] * energy_mwh_per_slot).sum())
        act_rev = up_rev + down_rev

        monthly_rows.append({
            'month': str(month),
            'hours_in_data': hours_in_data,
            'capacity_revenue_eur': cap_rev,
            'activation_revenue_eur': act_rev,
            'total_revenue_eur': cap_rev + act_rev,
            'up_slots': int(up_mask.sum()),
            'down_slots': int(down_mask.sum()),
        })
        cap_total += cap_rev
        act_total += act_rev

    monthly_rows.sort(key=lambda x: x['month'])

    return {
        'monthly': monthly_rows,
        'totals': {
            'capacity_revenue_eur': cap_total,
            'activation_revenue_eur': act_total,
            'total_revenue_eur': cap_total + act_total,
            'months': len(monthly_rows)
        }
    }




def apply_soc_constraints_to_activation(
    df: pd.DataFrame,
    up_mask: pd.Series,
    down_mask: pd.Series,
    energy_per_slot_mwh: pd.Series,
    battery_capacity_mwh: float,
    initial_soc: float = 0.5,
    soc_min: float = 0.1,
    soc_max: float = 0.9,
    round_trip_efficiency: float = 0.9,
) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """Apply battery SOC constraints to FR activation events.

    Parameters
    ----------
    df : pd.DataFrame
        Dataframe with date/slot columns (must be sorted chronologically)
    up_mask : pd.Series
        Boolean mask indicating up-regulation activation (discharge)
    down_mask : pd.Series
        Boolean mask indicating down-regulation activation (charge)
    energy_per_slot_mwh : pd.Series
        Planned energy per 15-min slot before SOC constraints
    battery_capacity_mwh : float
        Battery energy capacity (MWh)
    initial_soc : float, optional
        Starting SOC fraction (0-1), default 0.5 (50%)
    soc_min : float, optional
        Minimum allowed SOC fraction (0-1), default 0.1 (10%)
    soc_max : float, optional
        Maximum allowed SOC fraction (0-1), default 0.9 (90%)
    round_trip_efficiency : float, optional
        Round-trip efficiency (0-1), default 0.9

    Returns
    -------
    constrained_up_energy : pd.Series
        Actual up-regulation energy after SOC constraints (MWh)
    constrained_down_energy : pd.Series
        Actual down-regulation energy after SOC constraints (MWh)
    soc_series : pd.Series
        SOC evolution over time (0-1 fraction)

    Notes
    -----
    Romania's ANRE regulations require batteries to maintain operational SOC ranges
    to ensure continued FR availability. This function simulates realistic physical
    constraints:
    - Cannot discharge below SOC_min (typically 10-20%)
    - Cannot charge above SOC_max (typically 80-90%)
    - Efficiency losses occur during charge/discharge cycles
    - SOC must be managed to maintain bi-directional capability

    When SOC constraints are violated, activation energy is reduced or blocked,
    which directly impacts revenue and demonstrates why SOC management is critical
    for FR participation.
    """
    n = len(df)
    soc = np.full(n, initial_soc, dtype=float)
    actual_up_energy = np.zeros(n, dtype=float)
    actual_down_energy = np.zeros(n, dtype=float)

    charge_efficiency = np.sqrt(round_trip_efficiency)  # √η for charge
    discharge_efficiency = np.sqrt(round_trip_efficiency)  # √η for discharge

    for i in range(n):
        # Start with previous SOC
        if i > 0:
            soc[i] = soc[i - 1]

        current_soc = soc[i]
        available_energy_mwh = current_soc * battery_capacity_mwh
        available_headroom_mwh = (soc_max - current_soc) * battery_capacity_mwh

        # Up-regulation (discharge): limited by available energy above SOC_min
        if up_mask.iloc[i]:
            max_discharge = max(0.0, (current_soc - soc_min) * battery_capacity_mwh)
            requested_discharge = energy_per_slot_mwh.iloc[i]
            actual_discharge = min(requested_discharge, max_discharge)

            actual_up_energy[i] = actual_discharge
            # Update SOC: discharge reduces SOC
            energy_from_battery = actual_discharge / discharge_efficiency  # Account for discharge inefficiency
            soc[i] = max(soc_min, current_soc - (energy_from_battery / battery_capacity_mwh))

        # Down-regulation (charge): limited by available headroom below SOC_max
        elif down_mask.iloc[i]:
            max_charge = max(0.0, available_headroom_mwh)
            requested_charge = energy_per_slot_mwh.iloc[i]
            actual_charge = min(requested_charge, max_charge)

            actual_down_energy[i] = actual_charge
            # Update SOC: charge increases SOC (with losses)
            energy_to_battery = actual_charge * charge_efficiency  # Account for charge inefficiency
            soc[i] = min(soc_max, current_soc + (energy_to_battery / battery_capacity_mwh))

    return (
        pd.Series(actual_up_energy, index=df.index),
        pd.Series(actual_down_energy, index=df.index),
        pd.Series(soc, index=df.index),
    )



@st.cache_data(show_spinner=False)
def simulate_frequency_regulation_revenue_multi(
    prices_eur: pd.DataFrame,
    products: Dict[str, Dict[str, float]],
    pay_down_as_positive: bool = True,
    pay_down_positive_map: Optional[Dict[str, bool]] = None,
    activation_factor_map: Optional[Dict[str, float]] = None,
    calendars: Optional[Dict[str, pd.DataFrame]] = None,
    system_imbalance_df: Optional[pd.DataFrame] = None,
    activation_curve_map: Optional[Dict[str, pd.Series]] = None,
    activation_price_mode: str = "market",
    pay_as_bid_map: Optional[Dict[str, Dict[str, float]]] = None,
    battery_power_mw: Optional[float] = None,
    battery_capacity_mwh: Optional[float] = None,
    initial_soc: float = 0.5,
    soc_min: float = 0.1,
    soc_max: float = 0.9,
    round_trip_efficiency: float = 0.9,
    enable_soc_tracking: bool = True,
    merit_order_activation_rate: float = 0.5,
) -> Dict:
    """Multi-product simulation for FCR/aFRR/mFRR with SOC tracking and merit-order logic.

    Parameters
    ----------
    battery_capacity_mwh : float, optional
        Battery energy capacity in MWh. Required if enable_soc_tracking=True.
    initial_soc : float, default 0.5
        Initial State of Charge as fraction (0-1)
    soc_min : float, default 0.1
        Minimum allowed SOC (0-1)
    soc_max : float, default 0.9
        Maximum allowed SOC (0-1)
    round_trip_efficiency : float, default 0.9
        Battery round-trip efficiency (0-1)
    enable_soc_tracking : bool, default True
        Enable realistic SOC constraints on activation energy
    merit_order_activation_rate : float, default 0.5
        Conservative activation rate (0-1) to model merit-order dispatch.
        Represents average probability of activation based on bid position.
        0.3 = aggressive low bids (30% avg activation)
        0.5 = mid-stack bids (50% avg activation)
        0.7 = conservative high bids (70% avg activation)

    Products format example:
    {
      'FCR': {'enabled': True, 'mw': 10, 'cap_eur_mw_h': 7.5, 'up_thr': 0.0, 'down_thr': 0.0},
      'aFRR': {'enabled': True, 'mw': 15, 'cap_eur_mw_h': 5.0, 'up_thr': 0.0, 'down_thr': 0.0},
      'mFRR': {'enabled': False, 'mw': 0,  'cap_eur_mw_h': 0.0, 'up_thr': 0.0, 'down_thr': 0.0},
    }

    Notes
    -----
    Romania Pay-as-Bid Regime (ANRE 2024):
    - From July 2024 until December 31, 2026, balancing market uses pay-as-bid pricing
    - Each provider receives their bid price, not the marginal market price
    - Set activation_price_mode="pay_as_bid" and provide pay_as_bid_map
    - After 2026, market may revert to marginal pricing (update activation_price_mode accordingly)
    """
    if prices_eur is None or prices_eur.empty:
        return {'monthly_by_product': {}, 'totals_by_product': {}, 'combined_monthly': [], 'combined_totals': {'capacity_revenue_eur': 0.0, 'activation_revenue_eur': 0.0, 'total_revenue_eur': 0.0, 'months': 0}}

    df = prices_eur.copy()
    df['date'] = pd.to_datetime(df['date'])
    df['month'] = df['date'].dt.to_period('M')

    has_imbalance = (system_imbalance_df is not None) and (not system_imbalance_df.empty)

    monthly_by_product: Dict[str, List[Dict]] = {}
    totals_by_product: Dict[str, Dict[str, float]] = {}

    # For combined monthly, accumulate by month label
    combined_month_map: Dict[str, Dict[str, float]] = {}

    for prod, cfg in products.items():
        if not cfg.get('enabled'):
            continue
        mw = float(cfg.get('mw', 0.0))
        cap = float(cfg.get('cap_eur_mw_h', 0.0))
        up_thr = float(cfg.get('up_thr', 0.0))
        down_thr = float(cfg.get('down_thr', 0.0))
        if mw <= 0:
            continue

        rows = []
        cap_total = 0.0
        act_total = 0.0
        # Merge with calendar if provided
        if calendars and prod in calendars and calendars[prod] is not None and not calendars[prod].empty:
            cal = calendars[prod].copy()
            cal['date'] = pd.to_datetime(cal['date'])
            merged = df.merge(cal, on=['date', 'slot'], how='left')
            # Determine available MW per slot
            if 'available_mw' in merged.columns:
                avail_mw_series = merged['available_mw'].fillna(0.0).astype(float).clip(lower=0.0)
                avail_mw_series = avail_mw_series.apply(lambda v: min(mw, v))
            elif 'available' in merged.columns:
                avail_mw_series = merged['available'].fillna(0).astype(float) * mw
            else:
                avail_mw_series = pd.Series([mw] * len(merged), index=merged.index)
            merged['avail_mw'] = avail_mw_series
        else:
            merged = df.copy()
            merged['avail_mw'] = mw

        # Merge system imbalance if provided
        if has_imbalance:
            simbal = system_imbalance_df.copy()
            simbal['date'] = pd.to_datetime(simbal['date'])
            merged = merged.merge(simbal, on=['date','slot'], how='left')

        for month, mdf in merged.groupby('month'):
            hours_in_data = len(mdf) * 0.25

            # ===== CAPACITY REVENUE (€/MW/h) =====
            # Paid for availability regardless of activation
            # Formula: Σ(available_MW × hours_per_slot × capacity_price)
            # Example: 10 MW × 0.25h × 7.5 €/MW/h = 18.75€ per 15-min slot
            slot_cap_mw = mdf['avail_mw']
            if battery_power_mw is not None:
                slot_cap_mw = np.minimum(slot_cap_mw, float(battery_power_mw))
            cap_rev = float((slot_cap_mw * 0.25 * cap).sum())

            # ===== ACTIVATION REVENUE (€/MWh) =====
            # Paid for actual energy delivered when called upon
            # Formula: Σ(activation_price × energy_delivered_MWh)
            # Example: 210 €/MWh × 5 MWh = 1,050€ for one activation

            # Check if DAMAS actual activation data is available
            use_damas_activation = False
            damas_up_col = None
            damas_down_col = None
            damas_up_price_col = None
            damas_down_price_col = None

            # Map product names to DAMAS column names
            if prod == 'FCR' and 'fcr_activated_mwh' in mdf.columns:
                use_damas_activation = True
                damas_up_col = 'fcr_activated_mwh'
                # FCR doesn't have separate up/down prices in DAMAS
            elif prod == 'aFRR':
                if 'afrr_up_activated_mwh' in mdf.columns and 'afrr_down_activated_mwh' in mdf.columns:
                    use_damas_activation = True
                    damas_up_col = 'afrr_up_activated_mwh'
                    damas_down_col = 'afrr_down_activated_mwh'
                    damas_up_price_col = 'afrr_up_price_eur'
                    damas_down_price_col = 'afrr_down_price_eur'
            elif prod == 'mFRR':
                if 'mfrr_up_activated_mwh' in mdf.columns and 'mfrr_down_activated_mwh' in mdf.columns:
                    use_damas_activation = True
                    damas_up_col = 'mfrr_up_activated_mwh'
                    damas_down_col = 'mfrr_down_activated_mwh'
                    damas_up_price_col = 'mfrr_up_scheduled_price_eur'
                    damas_down_price_col = 'mfrr_down_scheduled_price_eur'

            if use_damas_activation:
                # USE ACTUAL TSO ACTIVATION DATA (90-95% accuracy)
                activation_method = "DAMAS_ACTUAL_TSO_ACTIVATION"

                # Masks based on actual TSO activation (not price thresholds!)
                if damas_up_col:
                    up_mask = mdf[damas_up_col].fillna(0) > 0
                else:
                    up_mask = pd.Series(False, index=mdf.index)

                if damas_down_col:
                    down_mask = mdf[damas_down_col].fillna(0) > 0
                else:
                    down_mask = pd.Series(False, index=mdf.index)

            else:
                # FALLBACK: Price-based activation is a PROXY, not actual TSO dispatch
                # Real FR energy comes from TSO activation signals, not price thresholds
                activation_method = "price_threshold_only"

                up_mask = mdf['price_eur_mwh'] >= up_thr
                down_mask = mdf['price_eur_mwh'] <= -down_thr

                if has_imbalance and ('imbalance_mw' in mdf.columns):
                    # Filter to only activate when system imbalance direction matches
                    up_mask = up_mask & (mdf['imbalance_mw'].fillna(0) > 0)
                    down_mask = down_mask & (mdf['imbalance_mw'].fillna(0) < 0)
                    activation_method = "price_threshold_with_imbalance_direction"

            # Apply per-product activation factor (0..1)
            act_factor_default = 1.0
            if activation_factor_map and prod in activation_factor_map:
                try:
                    act_factor_default = max(0.0, float(activation_factor_map.get(prod, 1.0)))
                except Exception:
                    act_factor_default = 1.0

            custom_activation = None
            if activation_curve_map and prod in activation_curve_map:
                custom_activation = activation_curve_map.get(prod)

            if custom_activation is not None and not custom_activation.empty:
                lookup_index = pd.MultiIndex.from_arrays([
                    mdf['date'].values,
                    mdf['slot'].astype(int).values,
                ])
                looked_up = custom_activation.reindex(lookup_index)
                act_factor_series = pd.Series(looked_up.values, index=mdf.index)
                act_factor_series = act_factor_series.fillna(act_factor_default).clip(lower=0.0, upper=1.0)
            else:
                act_factor_series = pd.Series(act_factor_default, index=mdf.index)

            if use_damas_activation:
                # USE ACTUAL MARKET ACTIVATION VOLUMES from DAMAS
                # Calculate our share based on market total and our contracted MW

                # Get total market activation volumes (MWh per 15-min slot)
                market_up_mwh = mdf[damas_up_col].fillna(0) if damas_up_col else pd.Series(0, index=mdf.index)
                market_down_mwh = mdf[damas_down_col].fillna(0) if damas_down_col else pd.Series(0, index=mdf.index)

                # Our maximum activation per slot (MWh)
                our_max_energy_per_slot = mdf['avail_mw'] * act_factor_series * 0.25
                if battery_power_mw is not None:
                    our_max_energy_per_slot = np.minimum(our_max_energy_per_slot, float(battery_power_mw) * 0.25)

                # Our actual activation is limited by:
                # 1. Market total activation (can't activate more than market needed)
                # 2. Our contracted capacity
                # 3. Merit-order position (not always dispatched)

                # Calculate energy per slot using market data
                energy_per_slot_up = np.minimum(our_max_energy_per_slot, market_up_mwh) * merit_order_activation_rate
                energy_per_slot_down = np.minimum(our_max_energy_per_slot, market_down_mwh) * merit_order_activation_rate

                # Combined energy series (will be split by up/down masks later)
                energy_per_slot_series = pd.Series(0.0, index=mdf.index)
                energy_per_slot_series[up_mask] = energy_per_slot_up[up_mask]
                energy_per_slot_series[down_mask] = energy_per_slot_down[down_mask]

            else:
                # FALLBACK: Price-threshold based energy calculation
                slot_act_mw = mdf['avail_mw'] * act_factor_series
                # Battery power cap during activation
                if battery_power_mw is not None:
                    slot_act_mw = np.minimum(slot_act_mw, float(battery_power_mw))
                if has_imbalance and 'imbalance_mw' in mdf.columns:
                    imbalance_cap = pd.to_numeric(mdf['imbalance_mw'], errors='coerce').abs()
                    capped = np.minimum(slot_act_mw, imbalance_cap)
                    slot_act_mw = slot_act_mw.where(imbalance_cap.isna(), capped)
                energy_per_slot_series = slot_act_mw * 0.25

                # Apply merit-order activation rate (models realistic dispatch probability)
                # This accounts for the fact that you're not always first in the merit order stack
                energy_per_slot_series = energy_per_slot_series * merit_order_activation_rate

            # Apply SOC tracking constraints if enabled and battery capacity is provided
            if enable_soc_tracking and battery_capacity_mwh and battery_capacity_mwh > 0:
                # Apply physical SOC constraints to activation energy
                actual_up_energy, actual_down_energy, soc_series = apply_soc_constraints_to_activation(
                    df=mdf.reset_index(drop=True),
                    up_mask=up_mask.reset_index(drop=True),
                    down_mask=down_mask.reset_index(drop=True),
                    energy_per_slot_mwh=energy_per_slot_series.reset_index(drop=True),
                    battery_capacity_mwh=battery_capacity_mwh,
                    initial_soc=initial_soc,
                    soc_min=soc_min,
                    soc_max=soc_max,
                    round_trip_efficiency=round_trip_efficiency,
                )
                # Overwrite planned energy with SOC-constrained energy
                energy_per_slot_series = pd.Series(0.0, index=mdf.index)
                energy_per_slot_series[up_mask] = actual_up_energy[up_mask.reset_index(drop=True)]
                energy_per_slot_series[down_mask] = actual_down_energy[down_mask.reset_index(drop=True)]

            # PRICING: Use DAMAS marginal prices when available
            if use_damas_activation and damas_up_price_col and damas_up_price_col in mdf.columns:
                # USE ACTUAL MARGINAL MARKET PRICES from DAMAS
                up_price_series = mdf[damas_up_price_col].fillna(0)
                if damas_down_price_col and damas_down_price_col in mdf.columns:
                    down_price_series = mdf[damas_down_price_col].fillna(0)
                else:
                    down_price_series = up_price_series.copy()
            else:
                # FALLBACK: Use imbalance prices or pay-as-bid prices
                price_series = mdf['price_eur_mwh']

                activation_price_mode_lower = (activation_price_mode or "market").lower()
                up_price_series = price_series.copy()
                down_price_series = price_series.copy()

                if activation_price_mode_lower == "pay_as_bid" and pay_as_bid_map and prod in pay_as_bid_map:
                    pay_prices = pay_as_bid_map.get(prod, {})
                    try:
                        up_const = float(pay_prices.get('up_price', up_price_series.mean()))
                    except Exception:
                        up_const = float(up_price_series.mean()) if not up_price_series.empty else 0.0
                    try:
                        down_const = float(pay_prices.get('down_price', up_const))
                    except Exception:
                        down_const = up_const
                    up_price_series = pd.Series(up_const, index=mdf.index)
                    down_price_series = pd.Series(down_const, index=mdf.index)

            up_rev = float((up_price_series[up_mask] * energy_per_slot_series[up_mask]).sum())
            # Per-product override for down-activation settlement sign
            prod_down_positive = pay_down_positive_map.get(prod, pay_down_as_positive) if pay_down_positive_map else pay_down_as_positive
            if prod_down_positive:
                down_rev = float((down_price_series[down_mask].abs() * energy_per_slot_series[down_mask]).sum())
            else:
                down_rev = float((down_price_series[down_mask] * energy_per_slot_series[down_mask]).sum())
            act_rev = up_rev + down_rev
            act_energy = float(energy_per_slot_series.sum())

            # Calculate net energy position for hedging
            # Up-regulation = discharge (need to buy back energy)
            # Down-regulation = charge (sell energy)
            up_energy = float(energy_per_slot_series[up_mask].sum())
            down_energy = float(energy_per_slot_series[down_mask].sum())
            net_energy = up_energy - down_energy  # Positive = net discharge, need to hedge

            # Use hedge curve when available; otherwise use average PZU price for net position
            hedge_prices = None
            if 'hedge_price_eur_mwh' in mdf.columns:
                try:
                    hedge_prices = pd.to_numeric(mdf['hedge_price_eur_mwh'], errors='coerce')
                except Exception:
                    hedge_prices = None

            if hedge_prices is not None and hedge_prices.notna().any():
                # Use slot-by-slot PZU hedge prices
                hedge_prices = hedge_prices.fillna(hedge_prices.mean())
                energy_cost = float(
                    (energy_per_slot_series[up_mask] * hedge_prices[up_mask]).sum()
                    + (energy_per_slot_series[down_mask] * hedge_prices[down_mask]).sum()
                )
            else:
                # Fallback: use monthly average PZU price for net position only
                # This avoids double-counting - you only hedge the NET energy imbalance
                avg_hedge_price = hedge_prices.mean() if hedge_prices is not None else price_series.abs().mean()
                energy_cost = float(net_energy * avg_hedge_price) if net_energy > 0 else 0.0

            # Calculate activation hours and events for debugging
            activation_slots = int(up_mask.sum() + down_mask.sum())
            activation_hours = activation_slots * 0.25

            # Count "events" as threshold crossings (transitions from inactive to active)
            combined_mask = up_mask | down_mask
            activation_events = int((combined_mask.astype(int).diff() > 0).sum())

            try:
                total_rev = cap_rev + act_rev
                cap_pct = (cap_rev / total_rev * 100) if total_rev > 0 else 0
                act_pct = (act_rev / total_rev * 100) if total_rev > 0 else 0

                print(
                    f"[FR DEBUG] {prod} {month}: "
                    f"CAPACITY={cap_rev:.2f}€ ({cap_pct:.0f}%) + "
                    f"ACTIVATION={act_rev:.2f}€ ({act_pct:.0f}%) = "
                    f"TOTAL={total_rev:.2f}€"
                )
                print(
                    f"[FR DEBUG] {prod} {month}: "
                    f"energy={act_energy:.2f}MWh hedge_cost={energy_cost:.2f}€ "
                    f"net_profit={(cap_rev + act_rev - energy_cost):.2f}€ pricing={activation_price_mode_lower}"
                )
                print(
                    f"[FR DEBUG] {prod} {month}: "
                    f"activation_hours={activation_hours:.1f}h activation_slots={activation_slots} "
                    f"activation_events={activation_events} "
                    f"up_slots={int(up_mask.sum())} down_slots={int(down_mask.sum())}"
                )
                print(
                    f"[FR DEBUG] {prod} {month}: "
                    f"up_energy={up_energy:.2f}MWh down_energy={down_energy:.2f}MWh "
                    f"net_energy={net_energy:.2f}MWh (positive=discharge)"
                )
                if activation_energy > 0:
                    avg_price = act_rev / act_energy
                    print(f"[FR DEBUG] {prod} {month}: avg_activation_price={avg_price:.2f}€/MWh")
                if hedge_prices is not None and hedge_prices.notna().any():
                    print(f"[FR DEBUG] {prod} {month}: using PZU hedge curve (avg={hedge_prices.mean():.2f}€/MWh)")
                else:
                    print(f"[FR DEBUG] {prod} {month}: using net position hedge (avg={avg_hedge_price:.2f}€/MWh)")
                print(f"[FR DEBUG] {prod} {month}: activation_method={activation_method}")
            except Exception:
                pass

            row = {
                'month': str(month),
                'hours_in_data': hours_in_data,
                'capacity_revenue_eur': cap_rev,
                'activation_revenue_eur': act_rev,
                'total_revenue_eur': cap_rev + act_rev,
                'up_slots': int(up_mask.sum()),
                'down_slots': int(down_mask.sum()),
                'activation_energy_mwh': act_energy,
                'energy_cost_eur': energy_cost,
            }
            rows.append(row)
            cap_total += cap_rev
            act_total += act_rev

            # Update combined monthly
            mkey = str(month)
            agg = combined_month_map.setdefault(mkey, {
                'month': mkey,
                'hours_in_data': 0.0,
                'capacity_revenue_eur': 0.0,
                'activation_revenue_eur': 0.0,
                'total_revenue_eur': 0.0,
                'up_slots': 0,
                'down_slots': 0,
                'activation_energy_mwh': 0.0,
                'energy_cost_eur': 0.0,
            })
            agg['hours_in_data'] = max(agg['hours_in_data'], hours_in_data)
            agg['capacity_revenue_eur'] += cap_rev
            agg['activation_revenue_eur'] += act_rev
            agg['total_revenue_eur'] += (cap_rev + act_rev)
            agg['up_slots'] += int(up_mask.sum())
            agg['down_slots'] += int(down_mask.sum())
            agg['activation_energy_mwh'] += act_energy
            agg['energy_cost_eur'] += energy_cost

        rows.sort(key=lambda x: x['month'])
        monthly_by_product[prod] = rows
        totals_by_product[prod] = {
            'capacity_revenue_eur': cap_total,
            'activation_revenue_eur': act_total,
            'total_revenue_eur': cap_total + act_total,
            'energy_cost_eur': float(sum(r['energy_cost_eur'] for r in rows)),
            'months': len(rows),
        }

    combined_monthly = sorted(combined_month_map.values(), key=lambda x: x['month'])
    comb_cap = sum(r['capacity_revenue_eur'] for r in combined_monthly)
    comb_act = sum(r['activation_revenue_eur'] for r in combined_monthly)
    comb_cost = sum(r.get('energy_cost_eur', 0.0) for r in combined_monthly)
    combined_totals = {
        'capacity_revenue_eur': comb_cap,
        'activation_revenue_eur': comb_act,
        'total_revenue_eur': comb_cap + comb_act,
        'energy_cost_eur': comb_cost,
        'months': len(combined_monthly),
    }

    try:
        comb_energy = sum(r.get('activation_energy_mwh', 0.0) for r in combined_monthly)
        print(
            f"[FR DEBUG] Combined totals: cap={comb_cap:.2f}€ act={comb_act:.2f}€ energy={comb_energy:.2f}MWh hedge_cost={comb_cost:.2f}€ months={len(combined_monthly)}",
        )
    except Exception:
        pass

    return {
        'monthly_by_product': monthly_by_product,
        'totals_by_product': totals_by_product,
        'combined_monthly': combined_monthly,
        'combined_totals': combined_totals,
    }

@st.cache_data(show_spinner=False)
def analyze_pzu_best_hours(pzu_csv: str, start_year: int = 2023, window_months: int = 12) -> Dict:
    """Compute hour-of-day average prices and best buy/sell hours over a historical window."""
    if not pzu_csv or not Path(pzu_csv).exists():
        return {'error': 'PZU CSV not found'}
    try:
        df = pd.read_csv(pzu_csv)
        df['date'] = pd.to_datetime(df['date'])
        df['month'] = df['date'].dt.to_period('M')
        df = df[df['date'] >= pd.Timestamp(year=start_year, month=1, day=1)]
        # keep last N months
        months_sorted = sorted(df['month'].unique())
        if not months_sorted:
            return {'error': 'No months found after filtering'}
        chosen = months_sorted[-window_months:]
        df = df[df['month'].isin(chosen)]
        # ensure full 24h days
        full_days = df.groupby('date')['hour'].count()
        valid_dates = full_days[full_days >= 24].index
        dfd = df[df['date'].isin(valid_dates)]
        # average by hour-of-day
        avg_by_hour = dfd.groupby('hour')['price'].mean().reindex(range(24)).fillna(method='ffill').fillna(method='bfill')
        # best hours: lowest 3 and highest 3
        best_buy = avg_by_hour.nsmallest(3)
        best_sell = avg_by_hour.nlargest(3)
        spread = float(best_sell.iloc[0] - best_buy.iloc[0])
        return {
            'window_months': len(chosen),
            'hours': list(range(24)),
            'avg_price_by_hour': [float(x) for x in avg_by_hour.values],
            'best_buy_hours': [{'hour': int(h), 'avg_price': float(v)} for h, v in best_buy.items()],
            'best_sell_hours': [{'hour': int(h), 'avg_price': float(v)} for h, v in best_sell.items()],
            'avg_spread_top_vs_bottom': spread,
            'start_month': str(chosen[0]) if chosen else None,
            'end_month': str(chosen[-1]) if chosen else None,
        }
    except Exception as e:
        return {'error': f'Failed to analyze PZU best hours: {e}'}

@st.cache_data(show_spinner=False)
def analyze_pzu_best_hours_min_years(
    pzu_csv: str,
    min_years: int = 3,
    round_trip_efficiency: float = 0.9,
    capacity_mwh: float = 0.0,
    investment_eur: float = 6_500_000,
) -> Dict:
    """Detect best buy/sell hours using minimum N years of PZU history and estimate arbitrage profits.
    Picks the hour-of-day with lowest average price as BUY and highest as SELL across the whole period.
    Returns daily and annual profit estimates (assuming one cycle/day), plus optional ROI.
    """
    if not pzu_csv or not Path(pzu_csv).exists():
        return {'error': 'PZU CSV not found'}
    try:
        df = pd.read_csv(pzu_csv)
        if not {'date','hour','price'}.issubset(df.columns):
            return {'error': 'PZU CSV must contain columns: date,hour,price'}
        df['date'] = pd.to_datetime(df['date'])
        months = df['date'].dt.to_period('M').unique()
        total_months = len(months)
        if total_months < (min_years * 12):
            return {
                'error': f'Insufficient history: found {total_months} months, need at least {min_years*12} months',
                'suggestion': 'Point pzu_forecast_csv to a >=3-year history (e.g., data/pzu_history_3y.csv)'
            }
        # Aggregate averages by hour-of-day over full history
        df_sorted = df.sort_values(['date','hour'])
        hourly_avg = df_sorted.groupby('hour')['price'].mean().reindex(range(24))
        buy_hour = int(hourly_avg.idxmin())
        sell_hour = int(hourly_avg.idxmax())
        avg_buy = float(hourly_avg.min())
        avg_sell = float(hourly_avg.max())
        # Correct: Profit = (sell_price × η - buy_price) × capacity
        net_spread = avg_sell * float(round_trip_efficiency) - avg_buy
        daily_profit = max(0.0, net_spread) * float(capacity_mwh)
        annual_profit = daily_profit * 365.0
        roi_percent = (annual_profit / float(investment_eur) * 100.0) if investment_eur and investment_eur > 0 else 0.0
        payback_years = (float(investment_eur) / annual_profit) if annual_profit > 0 else float('inf')
        return {
            'analysis_type': f'{min_years}-Year Best-Hour Arbitrage Estimate',
            'period_months': total_months,
            'data_period': f"{df['date'].min().date()} to {df['date'].max().date()}",
            'buy_hour': buy_hour,
            'sell_hour': sell_hour,
            'avg_buy_eur_mwh': avg_buy,
            'avg_sell_eur_mwh': avg_sell,
            'net_spread_eur_mwh': net_spread,
            'daily_profit_eur': daily_profit,
            'annual_profit_eur': annual_profit,
            'roi_annual_percent': roi_percent,
            'payback_years': payback_years,
        }
    except Exception as e:
        return {'error': f'Failed 3-year best-hour analysis: {e}'}

@st.cache_data(show_spinner=False)
def estimate_pzu_profit_window(
    pzu_csv: str,
    capacity_mwh: float,
    round_trip_efficiency: float = 0.9,
    days: Optional[int] = None,
    months: Optional[int] = None,
) -> Dict:
    """Estimate profit over the last N days or last N months using a simple daily min/max arbitrage.
    Returns used_days, used_months, total_profit_eur, avg_daily_profit_eur, annualized_profit_eur, data_period.
    """
    if not pzu_csv or not Path(pzu_csv).exists():
        return {'error': 'PZU CSV not found'}
    try:
        df = pd.read_csv(pzu_csv)
        if not {'date','hour','price'}.issubset(df.columns):
            return {'error': 'PZU CSV must contain columns: date,hour,price'}
        df['date'] = pd.to_datetime(df['date'])
        df = df.sort_values(['date','hour'])
        # Window selection
        used_months = 0
        if months is not None:
            uniq_months = sorted(df['date'].dt.to_period('M').unique())
            if len(uniq_months) == 0:
                return {'error': 'No months in dataset'}
            chosen = uniq_months[-int(months):]
            df = df[df['date'].dt.to_period('M').isin(chosen)]
            used_months = len(chosen)
        elif days is not None:
            uniq_days = sorted(df['date'].dt.date.unique())
            if len(uniq_days) == 0:
                return {'error': 'No days in dataset'}
            chosen_days = uniq_days[-int(days):]
            df = df[df['date'].dt.date.isin(chosen_days)]
        # Group by day and compute daily profit
        eta = float(round_trip_efficiency)
        cap = float(capacity_mwh)
        daily_profits: List[float] = []
        for _date, g in df.groupby(df['date'].dt.date):
            day_prices = g.sort_values('hour')['price']
            if len(day_prices) < 4:
                continue
            min_p = float(day_prices.min())
            max_p = float(day_prices.max())
            net = max_p - (min_p / eta)
            daily_profits.append(max(0.0, net) * cap)
        used_days = len(daily_profits)
        total_profit = float(sum(daily_profits))
        avg_daily = (total_profit / used_days) if used_days > 0 else 0.0
        # Annualize based on days covered
        annualized = avg_daily * 365.0
        period = f"{df['date'].min().date()} to {df['date'].max().date()}"
        return {
            'used_days': used_days,
            'used_months': used_months,
            'total_profit_eur': total_profit,
            'avg_daily_profit_eur': avg_daily,
            'annualized_profit_eur': annualized,
            'data_period': period,
        }
    except Exception as e:
        return {'error': f'Failed profit estimation: {e}'}

@st.cache_data(show_spinner=False)
def plan_multi_hour_strategy_from_history(
    pzu_csv: str,
    min_years: int,
    round_trip_efficiency: float,
    capacity_mwh: float,
    power_mw: float,
    buy_hours_buffer: int,
    sell_hours_buffer: int,
    cycles_per_day: int = 1,
    investment_eur: float = 6_500_000,
) -> Dict:
    """Plan a simple daily arbitrage using hour-of-day averages over >= N years.
    - Picks k lowest-avg hours for charging and k' highest-avg hours for discharging
    - Respects power and capacity, round-trip efficiency, and cycles/day budget
    - Approximates profit using average prices for chosen hours
    """
    if not pzu_csv or not Path(pzu_csv).exists():
        return {'error': 'PZU CSV not found'}
    try:
        df = pd.read_csv(pzu_csv)
        if not {'date','hour','price'}.issubset(df.columns):
            return {'error': 'PZU CSV must contain columns: date,hour,price'}
        df['date'] = pd.to_datetime(df['date'])
        months = df['date'].dt.to_period('M').unique()
        if len(months) < (min_years * 12):
            return {'error': f'Insufficient history: need >= {min_years} years'},
        hourly_avg = df.groupby('hour')['price'].mean().reindex(range(24))
        k_b = max(1, int(buy_hours_buffer))
        k_s = max(1, int(sell_hours_buffer))
        buy_hours = list(hourly_avg.nsmallest(k_b).index.astype(int))
        sell_hours = list(hourly_avg.nlargest(k_s).index.astype(int))
        avg_buy = float(hourly_avg.iloc[buy_hours].mean()) if k_b > 0 else float('nan')
        avg_sell = float(hourly_avg.iloc[sell_hours].mean()) if k_s > 0 else float('nan')
        e = float(round_trip_efficiency)
        cap = float(capacity_mwh)
        P = float(power_mw)
        # Energy per cycle limited by power windows and capacity + efficiency
        max_discharge_by_power = P * k_s
        max_charge_by_power = P * k_b
        max_discharge_by_capacity = e * min(cap, max_charge_by_power)
        E_discharge = max(0.0, min(max_discharge_by_power, max_discharge_by_capacity))
        # Profit per cycle based on prices
        profit_per_cycle = E_discharge * avg_sell - (E_discharge / e) * avg_buy if E_discharge > 0 else 0.0
        # Cycles/day limited by available hours
        max_cycles_by_hours = max(1, 24 // (k_b + k_s))
        cycles_used = max(1, min(int(cycles_per_day), int(max_cycles_by_hours)))
        daily_profit = profit_per_cycle * cycles_used
        annual_profit = daily_profit * 365.0
        roi_percent = (annual_profit / float(investment_eur) * 100.0) if investment_eur and annual_profit > 0 else 0.0
        payback_years = (float(investment_eur) / annual_profit) if annual_profit > 0 else float('inf')
        return {
            'analysis_type': f'{min_years}y Hour-of-day buffer strategy',
            'buy_hours': buy_hours,
            'sell_hours': sell_hours,
            'avg_buy_eur_mwh': avg_buy,
            'avg_sell_eur_mwh': avg_sell,
            'energy_sold_mwh_per_cycle': E_discharge,
            'profit_per_cycle_eur': profit_per_cycle,
            'cycles_used_per_day': cycles_used,
            'daily_profit_eur': daily_profit,
            'annual_profit_eur': annual_profit,
            'roi_annual_percent': roi_percent,
            'payback_years': payback_years,
        }
    except Exception as e:
        return {'error': f'Failed multi-hour strategy planning: {e}'}

def render_historical_market_comparison(cfg: dict, capacity_mwh: float, eta_rt: float) -> None:
    """Render comparison using cached results from PZU Horizons and FR Simulator."""
    st.caption("This comparison reuses the most recent runs of the PZU Horizons and FR Simulator views.")

    pzu_metrics = st.session_state.get("pzu_market_metrics")
    if not pzu_metrics or not isinstance(pzu_metrics, dict) or "daily_history" not in pzu_metrics:
        st.info("Run the PZU Horizons view and recompute results to populate comparison data.")
        return

    daily_history_raw = pzu_metrics.get("daily_history")
    if daily_history_raw is None:
        st.info("No PZU profitability data available. Run PZU Horizons first.")
        return

    if isinstance(daily_history_raw, pd.DataFrame):
        daily_history = daily_history_raw.copy()
    else:
        daily_history = pd.DataFrame(daily_history_raw)

    if daily_history.empty:
        st.info("No PZU profitability data available. Run PZU Horizons first.")
        return

    daily_history["date"] = pd.to_datetime(daily_history["date"], errors="coerce")
    daily_history = daily_history.dropna(subset=["date"]).sort_values("date")
    pzu_monthly = (
        daily_history.assign(month=daily_history["date"].dt.to_period("M"))
        .groupby("month", as_index=False)["daily_profit_eur"]
        .sum()
        .rename(columns={"daily_profit_eur": "total_profit_eur"})
    )
    pzu_monthly["month"] = pzu_monthly["month"].astype(str)
    total_months = len(pzu_monthly)
    if total_months == 0:
        st.info("No monthly PZU data available for comparison.")
        return

    default_window = min(12, total_months)
    window = st.slider("Window (months)", min_value=1, max_value=total_months, value=default_window, step=1)

    pzu_window = pzu_monthly.tail(window).reset_index(drop=True)
    pzu_total_profit = float(pzu_window["total_profit_eur"].sum())
    pzu_annualized_profit = pzu_total_profit * (12.0 / len(pzu_window)) if len(pzu_window) else 0.0

    fr_metrics = st.session_state.get("fr_market_metrics")
    fr_window = pd.DataFrame()
    fr_total_revenue = 0.0
    fr_annualized_revenue = 0.0
    if isinstance(fr_metrics, dict) and fr_metrics.get("months"):
        fr_months_df = pd.DataFrame(fr_metrics["months"])
        if not fr_months_df.empty and "month" in fr_months_df.columns:
            try:
                fr_months_df["month_period"] = pd.PeriodIndex(fr_months_df["month"], freq="M")
            except Exception:
                fr_months_df["month_period"] = pd.to_datetime(fr_months_df["month"], errors="coerce").dt.to_period("M")
            fr_months_df = fr_months_df.dropna(subset=["month_period"]).sort_values("month_period")
            fr_months_df["month"] = fr_months_df["month_period"].astype(str)

            # Fill months without activation entries using averages from observed months
            for col in ["energy_cost_eur", "activation_revenue_eur", "activation_energy_mwh"]:
                if col in fr_months_df.columns:
                    fr_months_df[col] = pd.to_numeric(fr_months_df[col], errors="coerce")

            cost_mask = fr_months_df.get("energy_cost_eur", pd.Series(dtype=float)).fillna(0.0) > 0.0
            if cost_mask.any():
                avg_cost = fr_months_df.loc[cost_mask, "energy_cost_eur"].mean()
                fr_months_df.loc[~cost_mask, "energy_cost_eur"] = avg_cost

            act_mask = fr_months_df.get("activation_revenue_eur", pd.Series(dtype=float)).fillna(0.0) > 0.0
            if act_mask.any():
                avg_act = fr_months_df.loc[act_mask, "activation_revenue_eur"].mean()
                fr_months_df.loc[~act_mask, "activation_revenue_eur"] = avg_act

            energy_mask = fr_months_df.get("activation_energy_mwh", pd.Series(dtype=float)).fillna(0.0) > 0.0
            if energy_mask.any():
                avg_energy = fr_months_df.loc[energy_mask, "activation_energy_mwh"].mean()
                fr_months_df.loc[~energy_mask, "activation_energy_mwh"] = avg_energy

            if {"capacity_revenue_eur", "activation_revenue_eur"}.issubset(fr_months_df.columns):
                fr_months_df["total_revenue_eur"] = (
                    fr_months_df["capacity_revenue_eur"].fillna(0.0)
                    + fr_months_df["activation_revenue_eur"].fillna(0.0)
                )

            window_fr = min(window, len(fr_months_df))
            if window_fr > 0:
                fr_window = fr_months_df.tail(window_fr).reset_index(drop=True)
                fr_total_revenue = float(fr_window["total_revenue_eur"].sum())
                fr_annualized_revenue = fr_total_revenue * (12.0 / window_fr)

    st.subheader("Aggregated Results")
    col1, col2 = st.columns(2)
    with col1:
        st.markdown("**OPCOM PZU (Arbitrage)**")
        st.metric("Total profit (window)", format_currency(pzu_total_profit, decimals=currency_decimals, thousands=thousands_sep))
        st.metric("Annualized profit", format_currency(pzu_annualized_profit, decimals=currency_decimals, thousands=thousands_sep))
        st.caption(
            "Months used: "
            + ", ".join(pzu_window["month"].tolist())
            if not pzu_window.empty
            else "No months selected"
        )
    with col2:
        st.markdown("**FR Revenue (TRANSELECTRICA)**")
        if not fr_window.empty:
            st.metric("Total revenue (window)", format_currency(fr_total_revenue, decimals=currency_decimals, thousands=thousands_sep))
            st.metric("Annualized revenue", format_currency(fr_annualized_revenue, decimals=currency_decimals, thousands=thousands_sep))
            window_energy_cost = float(fr_window.get("energy_cost_eur", 0.0).sum())
            st.metric(
                "Energy cost (window)",
                format_currency(window_energy_cost, decimals=currency_decimals, thousands=thousands_sep),
            )
            fr_net_margin = fr_total_revenue - window_energy_cost
            st.metric(
                "Net profit (window)",
                format_currency(fr_net_margin, decimals=currency_decimals, thousands=thousands_sep),
            )
            st.caption(
                "Months used: "
                + ", ".join(fr_window["month"].tolist())
            )
        else:
            st.info("FR Simulator data unavailable for the selected window.")

    st.subheader("PZU Monthly Detail")
    pzu_display = pzu_window.rename(columns={"month": "Month", "total_profit_eur": "Profit €"})
    pzu_display["Profit €"] = pzu_display["Profit €"].apply(
        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep)
    )
    st.dataframe(pzu_display, width='stretch')

    if not fr_window.empty:
        st.subheader("FR Monthly Detail")
        fr_display = fr_window.rename(
            columns={
                "month": "Month",
                "capacity_revenue_eur": "Capacity €",
                "activation_revenue_eur": "Activation €",
                "total_revenue_eur": "Total €",
            }
        )
        if "activation_energy_mwh" in fr_window.columns:
            fr_display["Energy MWh"] = fr_window["activation_energy_mwh"].map(lambda v: f"{float(v):.2f}")
        fr_display["Energy cost €"] = fr_window.get("energy_cost_eur", 0.0).apply(
            lambda v: format_currency(float(v), decimals=currency_decimals, thousands=thousands_sep)
        )
        for col in ["Capacity €", "Activation €", "Total €"]:
            fr_display[col] = fr_display[col].apply(
                lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep)
            )
        st.dataframe(fr_display, width='stretch')

        annual_info = fr_metrics.get("annual") if isinstance(fr_metrics, dict) else None
        three_year_info = fr_metrics.get("three_year") if isinstance(fr_metrics, dict) else None

        if annual_info:
            annual_table = pd.DataFrame(
                [
                    ("Capacity revenue (12m)", format_currency(annual_info.get("capacity", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Activation revenue (12m)", format_currency(annual_info.get("activation", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Total revenue (12m)", format_currency(annual_info.get("total", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Energy cost (12m)", format_currency(annual_info.get("energy_cost", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Debt service (12m)", format_currency(annual_info.get("debt", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Net profit (12m)", format_currency(annual_info.get("net", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                ],
                columns=["Metric", "Value"],
            )
            st.subheader("FR Annual Cash Flow (from simulator)")
            st.table(annual_table)
            source_months = annual_info.get("source_months")
            if source_months and source_months < 12:
                st.caption(f"Scaled from last {int(source_months)} month(s) of FR data.")

        if three_year_info:
            outlook_table = pd.DataFrame(
                [
                    ("Capacity revenue (3y sim)", format_currency(three_year_info.get("capacity", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Activation revenue (3y sim)", format_currency(three_year_info.get("activation", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Total revenue (3y sim)", format_currency(three_year_info.get("total", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Energy cost (3y)", format_currency(three_year_info.get("energy_cost", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Debt service (3y)", format_currency(three_year_info.get("debt", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Net profit (3y sim)", format_currency(three_year_info.get("net", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                ],
                columns=["Metric", "Value"],
            )
            st.subheader("FR Simulated 3-Year Outlook (from simulator)")
            st.table(outlook_table)
def render_frequency_regulation_simulator(cfg: dict) -> None:
    """Render the FR simulator UI (TRANSELECTRICA) with per-product split and optional calendars."""
    st.subheader("⚡ Frequency Regulation Revenue Simulator (TRANSELECTRICA)")
    st.caption("Models grid services revenue: capacity (€/MW/h) + activation (€/MWh). No arbitrage.")

    st.caption(
        "This simulator consumes Transelectrica’s **DAMAS activation dataset** when available (aFRR/mFRR energy + marginal prices). "
        "If the dataset is missing it falls back to the legacy price-threshold proxy, which is far less accurate."
    )

    with st.expander("What is this and how it works?", expanded=False):
        st.markdown(
            "- Operator: TRANSELECTRICA (TSO). Purpose: grid frequency regulation, not energy trading.\n"
            "- Inputs: contracted MW per product (FCR/aFRR/mFRR) and capacity €/MW/h.\n"
            "- Capacity revenue: Σ(available_MW × 0.25 h × capacity_price) over all 15‑minute slots.\n"
            "- Activation revenue: uses **actual DAMAS aFRR/mFRR energy + marginal prices** when the dataset is present.\n"
            "- Fallback: if DAMAS data is missing you can load legacy export‑8 files and the model reverts to the price-threshold proxy.\n"
            "- Data sources: `data/imbalance_history.csv` / `damas_complete_fr_dataset.csv` (built via DAMAS downloader).\n"
            "- Accuracy: DAMAS ≈ 90‑95% vs settlement; price proxy ≈ 60‑75%."
        )

    fr_cfg = cfg.get('fr_products', {}) if cfg else {}
    data_cfg = cfg.get('data', {}) if cfg else {}
    cfg_fx = float(data_cfg.get('fx_ron_per_eur', 5.0))

    sample_export8 = project_root / "data" / "export-8-sample.xlsx"
    sample_sysimb = project_root / "data" / "Estimated power system imbalance.xlsx"
    corrected_imbalance = project_root / "data" / "imbalance_history_corrected.csv"
    default_export8 = (
        str(corrected_imbalance)
        if corrected_imbalance.exists()
        else (
            "export-8.xlsx"
            if Path("export-8.xlsx").exists()
            else (
                "downloads/transelectrica_imbalance/export-8.xlsx"
                if Path("downloads/transelectrica_imbalance/export-8.xlsx").exists()
                else (str(sample_export8) if sample_export8.exists() else (
                    find_in_data_dir([
                        r"export-8\\.xlsx",
                        r"export_8\\.xlsx",
                        r"estimated.*price.*xlsx",
                        r"price.*imbalance.*xlsx",
                    ])
                    or ""
                ))
            )
        )
    )
    colx1, colx2 = st.columns([2, 1])
    with colx1:
        price_candidates = list_in_data_dir([r"imbalance_history_corrected\\.csv", r"export[-_]?8\\.xlsx", r"estimated.*price.*xlsx", r"price.*imbalance.*xlsx", r"imbalance.*price.*csv"]) or []
        if not price_candidates:
            price_candidates = list_in_data_dir([r".*\\.xlsx$", r".*\\.xls$"]) or []
        selected_price = st.selectbox("Detected price files", options=["(none)"] + price_candidates, key='fr_price_detect')
        if 'fr_price_path' not in st.session_state:
            st.session_state['fr_price_path'] = default_export8 or (price_candidates[0] if price_candidates else "")
        use_sel_price = st.button("Use selected price", key='fr_use_price')
        if use_sel_price and selected_price != "(none)":
            st.session_state['fr_price_path'] = selected_price
        export8_path = st.text_input("Path to export-8 Excel or folder", key='fr_price_path')

        # Notify user if corrected imbalance data is being used
        if export8_path and "imbalance_history_corrected.csv" in export8_path:
            st.info("✅ Using corrected imbalance data (RON→EUR conversion + 10x error fix applied). See DATA_VALIDATION_REPORT.md for details.")

        sysimb_candidates = list_in_data_dir([
            r"estimated.*power.*system.*imbalance",
            r"power.*system.*imbalance",
            r"imbalance.*system.*xlsx",
            r"imbalance.*system.*csv",
        ]) or []
        if not sysimb_candidates:
            sysimb_candidates = list_in_data_dir([r".*\\.xlsx$", r".*\\.xls$", r".*\\.csv$"]) or []
        selected_sysimb = st.selectbox(
            "Detected system imbalance files",
            options=["(none)"] + sysimb_candidates,
            key='fr_sysimb_detect',
        )
        if 'fr_sysimb_path' not in st.session_state:
            default_sysimb = ""
            if sample_sysimb.exists():
                default_sysimb = str(sample_sysimb)
            else:
                default_sysimb = find_in_data_dir([
                    r"estimated.*power.*system.*imbalance",
                    r"imbalance.*power.*system",
                ]) or ""
            st.session_state['fr_sysimb_path'] = default_sysimb
        use_sel_sysimb = st.button("Use selected imbalance", key='fr_use_sysimb')
        if use_sel_sysimb and selected_sysimb != "(none)":
            st.session_state['fr_sysimb_path'] = selected_sysimb
        sysimb_path = st.text_input("System imbalance Excel/folder", key='fr_sysimb_path')

    with colx2:
        excel_currency = st.selectbox("Excel currency", options=["RON","EUR"], index=0)
        fx_rate = st.number_input("FX RON/EUR", min_value=1.0, max_value=10.0, value=cfg_fx, step=0.1, help="Used if Excel prices are in RON/MWh")

    pay_down_positive = st.checkbox("Pay down‑activation as positive", value=True, help="If off, negative prices reduce revenue. Some products may be settled differently; this toggle lets you choose.")

    st.markdown("---")
    st.caption("Per-product settings (enable at least one):")
    e1, e2, e3 = st.columns(3)
    with e1:
        fcrd = fr_cfg.get('FCR', {})
        fcr_enabled = st.checkbox("Enable FCR", value=bool(fcrd.get('enabled', True)))
        fcr_mw = st.number_input("FCR MW (contracted)", min_value=0.0, max_value=200.0, value=float(fcrd.get('contracted_mw', 10.0)), step=1.0, help="MW reserved/contracted for FCR")
        fcr_cap = st.number_input("FCR capacity €/MW/h", min_value=0.0, max_value=1000.0, value=float(fcrd.get('capacity_eur_per_mw_h', 7.5)), step=0.5, help="Availability payment per MW per hour")
        fcr_up = st.number_input("FCR up threshold €/MWh", min_value=0.0, max_value=500.0, value=float(fcrd.get('up_threshold_eur_mwh', 0.0)), step=1.0, help="Min price to count up‑activation")
        fcr_down = st.number_input("FCR down threshold €/MWh", min_value=0.0, max_value=500.0, value=float(fcrd.get('down_threshold_eur_mwh', 0.0)), step=1.0, help="Min |price| to count down‑activation")
        fcr_down_pos = st.checkbox("FCR: down‑activation paid positive", value=True, help="Treat down regulation energy as positive revenue (|price| × energy)")
        fcr_act = st.number_input("FCR activation factor (0–1)", min_value=0.0, max_value=1.0, value=0.05, step=0.01, help="Scales activation energy to a realistic duty factor")
    with e2:
        afrrd = fr_cfg.get('aFRR', {})
        afrr_enabled = st.checkbox("Enable aFRR", value=bool(afrrd.get('enabled', True)))
        afrr_mw = st.number_input("aFRR MW (contracted)", min_value=0.0, max_value=200.0, value=float(afrrd.get('contracted_mw', 10.0)), step=1.0, help="MW reserved/contracted for aFRR")
        afrr_cap = st.number_input("aFRR capacity €/MW/h", min_value=0.0, max_value=1000.0, value=float(afrrd.get('capacity_eur_per_mw_h', 5.0)), step=0.5, help="Availability payment per MW per hour")
        afrr_up = st.number_input("aFRR up threshold €/MWh", min_value=0.0, max_value=500.0, value=float(afrrd.get('up_threshold_eur_mwh', 0.0)), step=1.0, help="Min price to count up‑activation")
        afrr_down = st.number_input("aFRR down threshold €/MWh", min_value=0.0, max_value=500.0, value=float(afrrd.get('down_threshold_eur_mwh', 0.0)), step=1.0, help="Min |price| to count down‑activation")
        afrr_down_pos = st.checkbox("aFRR: down‑activation paid positive", value=True)
        afrr_act = st.number_input("aFRR activation factor (0–1)", min_value=0.0, max_value=1.0, value=0.10, step=0.01)
    with e3:
        mfrrd = fr_cfg.get('mFRR', {})
        mfrr_enabled = st.checkbox("Enable mFRR", value=bool(mfrrd.get('enabled', False)))
        mfrr_mw = st.number_input("mFRR MW (contracted)", min_value=0.0, max_value=200.0, value=float(mfrrd.get('contracted_mw', 0.0)), step=1.0, help="MW reserved/contracted for mFRR")
        mfrr_cap = st.number_input("mFRR capacity €/MW/h", min_value=0.0, max_value=1000.0, value=float(mfrrd.get('capacity_eur_per_mw_h', 0.0)), step=0.5, help="Availability payment per MW per hour")
        mfrr_up = st.number_input("mFRR up threshold €/MWh", min_value=0.0, max_value=500.0, value=float(mfrrd.get('up_threshold_eur_mwh', 0.0)), step=1.0, help="Min price to count up‑activation")
        mfrr_down = st.number_input("mFRR down threshold €/MWh", min_value=0.0, max_value=500.0, value=float(mfrrd.get('down_threshold_eur_mwh', 0.0)), step=1.0, help="Min |price| to count down‑activation")
        mfrr_down_pos = st.checkbox("mFRR: down‑activation paid positive", value=True)
        mfrr_act = st.number_input("mFRR activation factor (0–1)", min_value=0.0, max_value=1.0, value=0.10, step=0.01)

    products_cfg = {
        'FCR': {'enabled': fcr_enabled, 'mw': fcr_mw, 'cap_eur_mw_h': fcr_cap, 'up_thr': fcr_up, 'down_thr': fcr_down},
        'aFRR': {'enabled': afrr_enabled, 'mw': afrr_mw, 'cap_eur_mw_h': afrr_cap, 'up_thr': afrr_up, 'down_thr': afrr_down},
        'mFRR': {'enabled': mfrr_enabled, 'mw': mfrr_mw, 'cap_eur_mw_h': mfrr_cap, 'up_thr': mfrr_up, 'down_thr': mfrr_down},
    }
    paydown_map = {'FCR': fcr_down_pos, 'aFRR': afrr_down_pos, 'mFRR': mfrr_down_pos}
    act_map = {'FCR': fcr_act, 'aFRR': afrr_act, 'mFRR': mfrr_act}

    ref_cols = st.columns(3)
    with ref_cols[0]:
        fcr_ref_mw = st.number_input(
            "FCR activation reference MW",
            min_value=1.0,
            max_value=2000.0,
            value=float(fr_cfg.get('FCR', {}).get('activation_reference_mw', 50.0)),
            step=1.0,
            help="Approximate total MW of imbalance reserve to normalise FCR activation factors.",
        )
    with ref_cols[1]:
        afrr_ref_mw = st.number_input(
            "aFRR activation reference MW",
            min_value=1.0,
            max_value=2000.0,
            value=float(fr_cfg.get('aFRR', {}).get('activation_reference_mw', 80.0)),
            step=1.0,
        )
    with ref_cols[2]:
        mfrr_ref_mw = st.number_input(
            "mFRR activation reference MW",
            min_value=1.0,
            max_value=2000.0,
            value=float(fr_cfg.get('mFRR', {}).get('activation_reference_mw', 120.0)),
            step=1.0,
        )

    smoothing_option = st.selectbox(
        "Activation profile smoothing",
        options=["Per ISP", "Monthly average"],
        index=1,
        help="Whether to average activation factors per 15-min slot or by month to reduce volatility.",
    )

    pricing_mode_label = st.selectbox(
        "Activation pricing mode",
        options=["Pay-as-bid (manual)", "Market prices (export data)"]
    )
    activation_price_mode = "pay_as_bid" if pricing_mode_label == "Pay-as-bid (manual)" else "market"

    pay_as_bid_map: Dict[str, Dict[str, float]] = {}
    if activation_price_mode == "pay_as_bid":
        st.caption("Enter the accepted pay-as-bid activation prices (€/MWh) for each product.")
        pay_cols = st.columns(3)
        with pay_cols[0]:
            fcr_up_price = st.number_input(
                "FCR up €/MWh",
                min_value=0.0,
                max_value=1000.0,
                value=float(fr_cfg.get('FCR', {}).get('pay_as_bid_up', 80.0)),
                step=1.0,
            )
            fcr_down_price = st.number_input(
                "FCR down €/MWh",
                min_value=-1000.0,
                max_value=1000.0,
                value=float(fr_cfg.get('FCR', {}).get('pay_as_bid_down', 80.0)),
                step=1.0,
            )
            pay_as_bid_map['FCR'] = {'up_price': fcr_up_price, 'down_price': fcr_down_price}
        with pay_cols[1]:
            afrr_up_price = st.number_input(
                "aFRR up €/MWh",
                min_value=0.0,
                max_value=1000.0,
                value=float(fr_cfg.get('aFRR', {}).get('pay_as_bid_up', 90.0)),
                step=1.0,
            )
            afrr_down_price = st.number_input(
                "aFRR down €/MWh",
                min_value=-1000.0,
                max_value=1000.0,
                value=float(fr_cfg.get('aFRR', {}).get('pay_as_bid_down', 90.0)),
                step=1.0,
            )
            pay_as_bid_map['aFRR'] = {'up_price': afrr_up_price, 'down_price': afrr_down_price}
        with pay_cols[2]:
            mfrr_up_price = st.number_input(
                "mFRR up €/MWh",
                min_value=0.0,
                max_value=1000.0,
                value=float(fr_cfg.get('mFRR', {}).get('pay_as_bid_up', 100.0)),
                step=1.0,
            )
            mfrr_down_price = st.number_input(
                "mFRR down €/MWh",
                min_value=-1000.0,
                max_value=1000.0,
                value=float(fr_cfg.get('mFRR', {}).get('pay_as_bid_down', 100.0)),
                step=1.0,
            )
            pay_as_bid_map['mFRR'] = {'up_price': mfrr_up_price, 'down_price': mfrr_down_price}

    st.caption("Optional availability calendars (CSV/XLSX). Columns: date, slot, available_mw or available(0/1).")
    cal1, cal2, cal3 = st.columns(3)
    with cal1:
        fcr_cal_path = st.text_input("FCR calendar path", value=str(fr_cfg.get('FCR', {}).get('calendar_csv', "")))
        fcr_cal_upload = st.file_uploader("Upload FCR calendar", type=['csv','xlsx','xls'], key='fcr_cal')
    with cal2:
        afrr_cal_path = st.text_input("aFRR calendar path", value=str(fr_cfg.get('aFRR', {}).get('calendar_csv', "")))
        afrr_cal_upload = st.file_uploader("Upload aFRR calendar", type=['csv','xlsx','xls'], key='afrr_cal')
    with cal3:
        mfrr_cal_path = st.text_input("mFRR calendar path", value=str(fr_cfg.get('mFRR', {}).get('calendar_csv', "")))
        mfrr_cal_upload = st.file_uploader("Upload mFRR calendar", type=['csv','xlsx','xls'], key='mfrr_cal')

    calendars_cfg: Dict[str, pd.DataFrame] = {}
    fcr_df = normalize_calendar_df(read_calendar_df(fcr_cal_upload) or read_calendar_df(fcr_cal_path))
    if fcr_df is not None:
        calendars_cfg['FCR'] = fcr_df
    afrr_df = normalize_calendar_df(read_calendar_df(afrr_cal_upload) or read_calendar_df(afrr_cal_path))
    if afrr_df is not None:
        calendars_cfg['aFRR'] = afrr_df
    mfrr_df = normalize_calendar_df(read_calendar_df(mfrr_cal_upload) or read_calendar_df(mfrr_cal_path))
    if mfrr_df is not None:
        calendars_cfg['mFRR'] = mfrr_df

    # Sanity check: enforce power cap warning and allow auto-load battery specs from technical proposal
    try:
        enabled_products = {'FCR': fcr_enabled, 'aFRR': afrr_enabled, 'mFRR': mfrr_enabled}
        mw_allocation = {'FCR': fcr_mw, 'aFRR': afrr_mw, 'mFRR': mfrr_mw}

        # Debug: show capacity allocation
        print("\n[CAPACITY ALLOCATION DEBUG]")
        print(f"Battery power limit: {power_mw:.1f} MW")
        print(f"Battery energy capacity: {capacity_mwh:.1f} MWh")
        for product in ['FCR', 'aFRR', 'mFRR']:
            if enabled_products[product]:
                print(f"  {product}: {mw_allocation[product]:.1f} MW (enabled)")
            else:
                print(f"  {product}: {mw_allocation[product]:.1f} MW (disabled)")

        total_mw = sum([v for k, v in mw_allocation.items() if enabled_products[k]])
        print(f"Total allocated: {total_mw:.1f} MW")
        print(f"Allocation ratio: {total_mw / power_mw * 100:.1f}% of battery capacity")

        if total_mw > power_mw:
            st.warning(f"⚠️ Total allocated MW ({total_mw:.1f} MW) exceeds battery power ({power_mw:.1f} MW). Consider reducing per‑product MW or using calendars.")
            print(f"[WARNING] Over-allocation: {total_mw - power_mw:.1f} MW excess")
    except Exception as e:
        print(f"[CAPACITY ALLOCATION DEBUG] Error: {e}")

    with st.expander("Battery specs (auto from Technical Proposal)", expanded=False):
        tech_doc = find_in_data_dir([r"technical.*proposal.*mey.*energy", r"20mw.*55mwh", r"bess.*project"]) or ""
        tech_path = st.text_input("Battery spec document (PDF)", value=tech_doc)
        use_specs = st.checkbox("Use extracted specs to cap power/efficiency", value=True)
        extracted = parse_battery_specs_from_document(tech_path) if tech_path else {}
        if extracted:
            st.json(extracted)
        # Apply extracted power and efficiency if available
        cap_power_mw = power_mw
        if use_specs and extracted:
            if extracted.get('power_mw'):
                cap_power_mw = float(extracted['power_mw'])
            if extracted.get('round_trip_efficiency'):
                st.caption(f"Using extracted round-trip efficiency {extracted['round_trip_efficiency']:.2f} for activation energy scaling (informational)")
        else:
            cap_power_mw = power_mw

    sysimb_df = pd.DataFrame()
    activation_reference_map = {
        'FCR': fcr_ref_mw,
        'aFRR': afrr_ref_mw,
        'mFRR': mfrr_ref_mw,
    }
    activation_curves_map: Dict[str, pd.Series] = {}

    if sysimb_path:
        try:
            sysimb_df = load_system_imbalance_from_excel(sysimb_path)
            if sysimb_df.empty:
                st.info("System imbalance file loaded but contained no usable rows.")
        except Exception as exc:
            sysimb_df = pd.DataFrame()
            st.warning(f"Failed to load system imbalance data: {exc}")

    smoothing_flag = 'monthly' if smoothing_option == 'Monthly average' else None

    if not sysimb_df.empty:
        for prod, ref in activation_reference_map.items():
            if ref and ref > 0:
                series = compute_activation_factor_series(sysimb_df, ref, smoothing=smoothing_flag)
                if not series.empty:
                    activation_curves_map[prod] = series
        if activation_curves_map:
            st.caption("Using system imbalance history to derive activation duty factors.")

    has_imbalance_flag = not sysimb_df.empty

    if export8_path:
        try:
            imb_df = load_transelectrica_imbalance_from_excel(
                export8_path,
                fx_ron_per_eur=(1.0 if excel_currency == 'EUR' else fx_rate),
                declared_currency=excel_currency,
            )
            if not imb_df.empty and any(v.get('enabled') and v.get('mw', 0) > 0 for v in products_cfg.values()):
                src_cur = []
                if 'source_currency' in imb_df.columns:
                    src_cur = sorted({str(v) for v in imb_df['source_currency'].dropna().unique() if str(v).strip()})
                if src_cur:
                    if len(src_cur) == 1:
                        cur_label = src_cur[0]
                        st.caption(f"Detected imbalance currency: {cur_label} (internal pricing in EUR)")
                        if excel_currency.upper() != cur_label:
                            st.info(
                                f"File reports {cur_label}; the '{excel_currency}' selection was overridden during import."
                            )
                    else:
                        st.caption(
                            "Detected imbalance currencies: "
                            + ", ".join(src_cur)
                            + " (each converted to EUR before simulation)"
                        )
                price_dates_ts = pd.to_datetime(imb_df['date'], errors='coerce').dropna()

                # DATA COMPLETENESS CHECK
                if not price_dates_ts.empty:
                    date_range = (price_dates_ts.max() - price_dates_ts.min()).days + 1
                    expected_records = date_range * 96  # 96 slots per day
                    actual_records = len(imb_df)
                    completeness = actual_records / expected_records if expected_records > 0 else 0

                    # Check slots per day
                    slots_per_day = imb_df.groupby('date')['slot'].count()
                    incomplete_days = (slots_per_day < 96).sum()

                    if completeness < 0.99 or incomplete_days > 0:
                        st.warning(
                            f"⚠️ Data completeness: {completeness*100:.1f}% "
                            f"({actual_records:,}/{expected_records:,} records). "
                            f"{incomplete_days} days have <96 slots. "
                            f"This will undercount capacity revenue and activation hours."
                        )

                    # Check for frequency column
                    if 'frequency' in imb_df.columns:
                        freq_missing = imb_df['frequency'].isna().mean()
                        if freq_missing > 0.9:
                            st.info(
                                "ℹ️ Frequency column is empty. System frequency data not available for activation modeling."
                            )

                hedge_coverage = 0.0
                hedge_avg = None
                if provider.pzu_csv and not price_dates_ts.empty:
                    hedge_curve = build_hedge_price_curve(
                        provider.pzu_csv,
                        start_date=price_dates_ts.min(),
                        end_date=price_dates_ts.max(),
                        fx_ron_per_eur=fx_rate,
                    )
                    if not hedge_curve.empty:
                        imb_df = imb_df.merge(hedge_curve, on=['date', 'slot'], how='left')
                        hedge_mask = imb_df['hedge_price_eur_mwh'].notna()
                        if hedge_mask.any():
                            hedge_coverage = float(hedge_mask.mean())
                            hedge_avg = float(imb_df.loc[hedge_mask, 'hedge_price_eur_mwh'].mean())
                            st.caption(
                                f"Energy cost reference: OPCOM PZU prices applied to {hedge_coverage*100:.1f}%"
                                " of slots"
                                + (f" (avg €{hedge_avg:.1f}/MWh)" if hedge_avg is not None else "")
                            )
                        else:
                            st.info("PZU hedge curve has no overlapping slots for this period; falling back to imbalance prices for energy cost.")
                    else:
                        st.info("PZU hedge curve not available for the selected window; falling back to imbalance prices for energy cost.")

                # Threshold suggestions from percentiles
                try:
                    pos = imb_df.loc[imb_df['price_eur_mwh'] > 0, 'price_eur_mwh']
                    neg = imb_df.loc[imb_df['price_eur_mwh'] < 0, 'price_eur_mwh'].abs()
                    if len(pos) > 0 or len(neg) > 0:
                        s1, s2 = st.columns(2)
                        with s1:
                            if len(pos) > 0:
                                st.caption("Suggested up thresholds (percentiles):")
                                st.write(f"P90: €{pos.quantile(0.9):.1f} | P95: €{pos.quantile(0.95):.1f}")
                        with s2:
                            if len(neg) > 0:
                                st.caption("Suggested down thresholds (percentiles of |price|):")
                                st.write(f"P90: €{neg.quantile(0.9):.1f} | P95: €{neg.quantile(0.95):.1f}")
                except Exception:
                    pass
                price_dates = pd.to_datetime(imb_df['date'], errors='coerce').dropna().dt.normalize().unique()
                has_imbalance_flag = bool(activation_curves_map)

                # Check if DAMAS activation data is available and merge it
                damas_path = project_root / "data" / "damas_complete_fr_dataset.csv"
                use_damas = damas_path.exists()

                if use_damas:
                    try:
                        # Load DAMAS data
                        damas_df = pd.read_csv(damas_path)
                        damas_df['date'] = pd.to_datetime(damas_df['date']).dt.date.astype(str)
                        damas_df['slot'] = damas_df['slot'].astype(int)

                        # Merge DAMAS activation data with imbalance prices
                        imb_df = imb_df.merge(
                            damas_df[['date', 'slot', 'fcr_activated_mwh', 'afrr_up_activated_mwh', 'afrr_down_activated_mwh',
                                     'mfrr_up_activated_mwh', 'mfrr_down_activated_mwh', 'afrr_up_price_eur',
                                     'afrr_down_price_eur', 'mfrr_up_scheduled_price_eur', 'mfrr_down_scheduled_price_eur',
                                     'system_imbalance_mwh']],
                            on=['date', 'slot'],
                            how='left'
                        )

                        # Count how many slots have DAMAS data
                        damas_coverage = (imb_df['afrr_up_activated_mwh'].notna()).mean()
                        st.success(f"🎯 Using DAMAS activation data (90-95% accuracy) - Coverage: {damas_coverage*100:.1f}% of slots have real TSO activation volumes")

                    except Exception as e:
                        st.warning(f"⚠️ DAMAS data available but couldn't merge: {e}. Using price-based method.")
                        use_damas = False

                simm = simulate_frequency_regulation_revenue_multi(
                    imb_df,
                    products_cfg,
                    pay_down_as_positive=pay_down_positive,
                    pay_down_positive_map=paydown_map,
                    activation_factor_map=act_map,
                    calendars=calendars_cfg,
                    system_imbalance_df=sysimb_df,
                    activation_curve_map=activation_curves_map,
                    activation_price_mode=activation_price_mode,
                    pay_as_bid_map=pay_as_bid_map if activation_price_mode == 'pay_as_bid' else None,
                    battery_power_mw=cap_power_mw,
                )

                # Add data source indicator
                if use_damas:
                    simm['combined_totals']['data_source'] = 'DAMAS_ACTUAL_ACTIVATION'
                    simm['combined_totals']['expected_accuracy'] = '90-95%'
                else:
                    simm['combined_totals']['data_source'] = 'PRICE_BASED_LEGACY'
                    simm['combined_totals']['expected_accuracy'] = '±25-35%'

                st.success(f"Computed revenue for {simm['combined_totals']['months']} months of data")
                months_comb = simm['combined_monthly']
                if months_comb:
                    st.subheader("Combined Monthly Revenue (All Products)")
                    comb_df = pd.DataFrame(months_comb)
                    currency_cols = ['capacity_revenue_eur','activation_revenue_eur','total_revenue_eur']
                    float_cols = ['hours_in_data']
                    if show_raw_tables:
                        st.dataframe(comb_df, width='stretch')
                    else:
                                st.dataframe(
                                    styled_table(
                                        comb_df,
                                        currency_cols=currency_cols,
                                        float_cols=float_cols,
                                        currency_decimals=currency_decimals,
                                        float_decimals=float_decimals,
                                        thousands=thousands_sep,
                                    ),
                                    width='stretch',
                                )

                    def sum_window(months, w):
                        sub = months[-w:]
                        cap = sum(m['capacity_revenue_eur'] for m in sub)
                        act = sum(m['activation_revenue_eur'] for m in sub)
                        tot = cap + act
                        return cap, act, tot, len(sub)

                    # Use only months we actually have
                    if len(months_comb) > 0:
                        cap_all = sum(m['capacity_revenue_eur'] for m in months_comb)
                        act_all = sum(m['activation_revenue_eur'] for m in months_comb)
                        tot_all = cap_all + act_all
                        energy_cost_total = float(sum(m.get('energy_cost_eur', 0.0) for m in months_comb))
                        activation_energy_total = float(sum(m.get('activation_energy_mwh', 0.0) for m in months_comb))
                        g1, g2, g3, g4 = st.columns(4)
                        label = f"{len(months_comb)}m"
                        g1.metric(f"Capacity revenue ({label})", format_currency(cap_all, decimals=currency_decimals, thousands=thousands_sep))
                        g2.metric(f"Activation revenue ({label})", format_currency(act_all, decimals=currency_decimals, thousands=thousands_sep))
                        g3.metric(f"Total ({label})", format_currency(tot_all, decimals=currency_decimals, thousands=thousands_sep))
                        g4.metric(
                            "Energy cost (window)",
                            format_currency(energy_cost_total, decimals=currency_decimals, thousands=thousands_sep),
                        )
                        st.caption(
                            f"Activation energy ({label}) ≈ {activation_energy_total:.0f} MWh"
                        )

                        try:
                            print(
                                f"[FR DEBUG] Window {label}: cap={cap_all:.2f}€ act={act_all:.2f}€ net_energy={activation_energy_total:.2f}MWh hedge_cost={energy_cost_total:.2f}€",
                            )
                        except Exception:
                            pass

                        # Highlight when external constraints suppress activation volumes
                        enabled_products = [
                            (prod, cfg)
                            for prod, cfg in products_cfg.items()
                            if cfg.get('enabled') and cfg.get('mw', 0) > 0
                        ]
                        total_enabled_mw = sum(cfg.get('mw', 0.0) for _, cfg in enabled_products)
                        if total_enabled_mw > 0:
                            weighted_activation = sum(
                                cfg.get('mw', 0.0) * act_map.get(prod, 1.0)
                                for prod, cfg in enabled_products
                            ) / total_enabled_mw
                            hours_total = sum(m.get('hours_in_data', 0.0) for m in months_comb)
                            theoretical_energy = hours_total * total_enabled_mw * weighted_activation
                            if theoretical_energy > 0:
                                utilisation = activation_energy_total / theoretical_energy
                                if utilisation < 0.15 and has_imbalance_flag:
                                    st.info(
                                        "Activation volumes are only "
                                        f"{utilisation:.1%} of the theoretical duty factor. Check the system imbalance data "
                                        "or activation factors if you expect higher dispatch."
                                    )

                        # Annual cash flow summary (normalized to 12 months)
                        annual_debt_service = 0.0
                        recent_months = months_comb[-12:]
                        months_used = len(recent_months)
                        if months_used > 0:
                            cap_recent = sum(m['capacity_revenue_eur'] for m in recent_months)
                            act_recent = sum(m['activation_revenue_eur'] for m in recent_months)
                            energy_recent = sum(m.get('activation_energy_mwh', 0.0) for m in recent_months)
                            energy_cost_recent = sum(m.get('energy_cost_eur', 0.0) for m in recent_months)
                            total_recent = cap_recent + act_recent
                            scale_factor = 12 / months_used
                            annual_cap = cap_recent * scale_factor
                            annual_act = act_recent * scale_factor
                            annual_total = annual_cap + annual_act
                            annual_energy = energy_recent * scale_factor
                            annual_energy_cost = energy_cost_recent * scale_factor
                            annual_net = annual_total - annual_debt_service - annual_energy_cost

                            annual_table = pd.DataFrame(
                                [
                                    ("Capacity revenue (12m)", format_currency(annual_cap, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Activation revenue (12m)", format_currency(annual_act, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Total revenue (12m)", format_currency(annual_total, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Energy cost (12m)", format_currency(annual_energy_cost, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Debt service (12m)", format_currency(annual_debt_service, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Net profit (12m)", format_currency(annual_net, decimals=currency_decimals, thousands=thousands_sep)),
                                ],
                                columns=["Metric", "Value"],
                            )
                            st.subheader("FR Annual Cash Flow (normalized 12m)")
                            st.table(annual_table)
                            if months_used < 12:
                                st.caption(f"Scaled from last {months_used} month(s) of data.")

                            three_year_cap = annual_cap * 3
                            three_year_act = annual_act * 3
                            three_year_total = annual_total * 3
                            three_year_debt = annual_debt_service * 3
                            three_year_energy_cost = annual_energy_cost * 3
                            three_year_net = three_year_total - three_year_debt - three_year_energy_cost

                            outlook_table = pd.DataFrame(
                                [
                                    ("Capacity revenue (3y sim)", format_currency(three_year_cap, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Activation revenue (3y sim)", format_currency(three_year_act, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Total revenue (3y sim)", format_currency(three_year_total, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Energy cost (3y)", format_currency(three_year_energy_cost, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Debt service (3y)", format_currency(three_year_debt, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Net profit (3y sim)", format_currency(three_year_net, decimals=currency_decimals, thousands=thousands_sep)),
                                ],
                                columns=["Metric", "Value"],
                            )
                            st.subheader("FR Simulated 3-Year Outlook")
                            st.table(outlook_table)

                            try:
                                months_payload = [
                                    sanitize_session_value(dict(rec)) for rec in months_comb
                                ]
                                annual_payload = sanitize_session_value(
                                    {
                                        "capacity": float(annual_cap),
                                        "activation": float(annual_act),
                                        "total": float(annual_total),
                                        "energy": float(annual_energy),
                                        "energy_cost": float(annual_energy_cost),
                                        "debt": float(annual_debt_service),
                                        "net": float(annual_net),
                                        "source_months": int(months_used),
                                        "cost_rate": (float(annual_energy_cost) / float(annual_energy)) if annual_energy > 0 else 0.0,
                                    }
                                )
                                three_year_payload = sanitize_session_value(
                                    {
                                        "capacity": float(three_year_cap),
                                        "activation": float(three_year_act),
                                        "total": float(three_year_total),
                                        "energy_cost": float(three_year_energy_cost),
                                        "debt": float(three_year_debt),
                                        "net": float(three_year_net),
                                    }
                                )
                                new_fr_metrics = {
                                    "months": months_payload,
                                    "annual": annual_payload,
                                    "three_year": three_year_payload,
                                }
                                safe_session_state_update("fr_market_metrics", new_fr_metrics)
                            except Exception:
                                pass

                            monthly_debt_share = annual_debt_service / 12.0 if annual_debt_service else 0.0
                            monthly_rows = []
                            for rec in months_comb:
                                month_label = rec.get("month") or rec.get("month_period")
                                month_label = str(month_label)
                                cap_val = float(rec.get("capacity_revenue_eur", 0.0))
                                act_val = float(rec.get("activation_revenue_eur", 0.0))
                                tot_val = cap_val + act_val
                                energy_val = float(rec.get('activation_energy_mwh', 0.0))
                                monthly_energy_cost = float(rec.get('energy_cost_eur', 0.0))
                                net_val = tot_val - monthly_debt_share - monthly_energy_cost
                                monthly_rows.append(
                                    {
                                        "Month": month_label,
                                        "Capacity €": format_currency(cap_val, decimals=currency_decimals, thousands=thousands_sep),
                                        "Activation €": format_currency(act_val, decimals=currency_decimals, thousands=thousands_sep),
                                        "Total €": format_currency(tot_val, decimals=currency_decimals, thousands=thousands_sep),
                                        "Energy MWh": f"{energy_val:.2f}",
                                        "Energy cost €": format_currency(monthly_energy_cost, decimals=currency_decimals, thousands=thousands_sep),
                                        "Debt share €": format_currency(monthly_debt_share, decimals=currency_decimals, thousands=thousands_sep) if monthly_debt_share else "—",
                                        "Net €": format_currency(net_val, decimals=currency_decimals, thousands=thousands_sep),
                                    }
                                )

                            if monthly_rows:
                                monthly_df = pd.DataFrame(monthly_rows)
                                st.subheader("FR Monthly Cash Flow (all months)")
                                st.dataframe(monthly_df, width='stretch')
                else:
                    st.session_state.pop("fr_market_metrics", None)

                st.subheader("Per-Product Revenue")
                for prod in ['FCR', 'aFRR', 'mFRR']:
                        if not products_cfg[prod]['enabled'] or products_cfg[prod]['mw'] <= 0:
                            continue
                        st.caption(f"{prod} contracted: {products_cfg[prod]['mw']} MW @ {products_cfg[prod]['cap_eur_mw_h']} €/MW/h")
                        months_prod = simm['monthly_by_product'].get(prod, [])
                        if months_prod:
                            prod_df = pd.DataFrame(months_prod)
                            currency_cols = ['capacity_revenue_eur','activation_revenue_eur','total_revenue_eur']
                            float_cols = ['hours_in_data']
                            if show_raw_tables:
                                st.dataframe(prod_df, width='stretch')
                            else:
                                st.dataframe(
                                    styled_table(
                                        prod_df,
                                        currency_cols=currency_cols,
                                        float_cols=float_cols,
                                        currency_decimals=currency_decimals,
                                        float_decimals=float_decimals,
                                        thousands=thousands_sep,
                                    ),
                                    width='stretch',
                                )
                            totp = simm['totals_by_product'].get(prod, {})
                            p1, p2, p3 = st.columns(3)
                            p1.metric(f"{prod} Capacity total", format_currency(totp.get('capacity_revenue_eur', 0), decimals=currency_decimals, thousands=thousands_sep))
                            p2.metric(f"{prod} Activation total", format_currency(totp.get('activation_revenue_eur', 0), decimals=currency_decimals, thousands=thousands_sep))
                            p3.metric(f"{prod} Total", format_currency(totp.get('total_revenue_eur', 0), decimals=currency_decimals, thousands=thousands_sep))
                            # Diagnostics: sum of up/down slots
                            ups = sum(r.get('up_slots', 0) for r in months_prod)
                            dns = sum(r.get('down_slots', 0) for r in months_prod)
                            st.caption(f"Diagnostics: up_slots={ups}, down_slots={dns}")
            else:
                st.info("Provide a valid export-8 path and enable at least one product with MW > 0.")
        except Exception as e:
            st.error(f"Failed to read export-8 file(s): {e}")

st.set_page_config(page_title="Battery Bot - PZU & Balancing", layout="wide", page_icon="⚡")

def apply_theme() -> None:
    css_path = project_root / "assets" / "style.css"
    try:
        css = css_path.read_text(encoding="utf-8") if css_path.exists() else ""
    except Exception:
        css = ""
    st.markdown(f"<style>{css}</style>", unsafe_allow_html=True)


st.title("Battery Trading Bot - Web Interface")
apply_theme()
st.caption("Choose a view below, set config in the sidebar, then Run Strategy.")



def render_investment_financing_analysis(cfg: dict) -> None:
    """Analyse investment and financing for FR and PZU businesses independently."""

    fr_metrics = st.session_state.get("fr_market_metrics")
    pzu_metrics = st.session_state.get("pzu_market_metrics")

    if not fr_metrics or not isinstance(fr_metrics, dict) or "annual" not in fr_metrics:
        st.info("Run the FR Simulator first to capture annual metrics.")
        return
    if not pzu_metrics or not isinstance(pzu_metrics, dict) or "daily_history" not in pzu_metrics:
        st.info("Run the PZU Horizons view to compute profitability before analysing financing.")
        return

    st.subheader("💸 Investment & Financing Analysis")

    battery_cfg = cfg.get("battery", {})
    investment_cfg = cfg.get("investment", {})

    default_power = float(battery_cfg.get("power_mw", 20.0))
    default_capex_per_mw = float(investment_cfg.get("capex_per_mw", 250_000.0))
    default_additional_costs = float(investment_cfg.get("additional_costs", 0.0))
    default_equity_pct = float(investment_cfg.get("equity_percent", 30.0))
    default_interest = float(investment_cfg.get("loan_interest_percent", 6.0))
    default_term = int(investment_cfg.get("loan_term_years", 7))
    default_fr_opex = float(investment_cfg.get("fr_operating_cost_annual", 0.0))
    default_pzu_opex = float(investment_cfg.get("pzu_operating_cost_annual", 0.0))

    col_inputs = st.columns(3)
    with col_inputs[0]:
        capex_per_mw = st.number_input(
            "Capex per MW (€/MW)",
            min_value=0.0,
            value=default_capex_per_mw,
            step=50_000.0,
            help="Capital expenditure per contracted MW of power.",
        )
    with col_inputs[1]:
        project_power_mw = st.number_input(
            "Installed power (MW)",
            min_value=0.0,
            value=default_power,
            step=1.0,
            help="Total power deployed for FR/PZU strategies.",
        )
    with col_inputs[2]:
        additional_costs = st.number_input(
            "Additional fixed costs (€)",
            min_value=0.0,
            value=default_additional_costs,
            step=100_000.0,
            help="Balance of plant, integration, or other upfront costs not captured in capex per MW.",
        )

    total_investment = capex_per_mw * project_power_mw + additional_costs
    st.metric("Total investment", format_currency(total_investment, decimals=0))

    col_fin = st.columns(3)
    with col_fin[0]:
        equity_pct = st.slider(
            "Equity share (%)",
            min_value=0,
            max_value=100,
            value=int(round(default_equity_pct)),
            help="Share of each business' investment covered with equity (remainder financed with debt).",
        )
    with col_fin[1]:
        interest_rate_pct = st.number_input(
            "Loan interest (% p.a.)",
            min_value=0.0,
            max_value=30.0,
            value=default_interest,
            step=0.1,
        )
    with col_fin[2]:
        loan_term_years = int(
            st.number_input(
                "Loan term (years)",
                min_value=1,
                max_value=25,
                value=default_term,
                step=1,
            )
        )

    investment_split_pct = st.slider(
        "Investment allocated to FR (%)",
        min_value=0,
        max_value=100,
        value=50,
        step=5,
        help="Share of the total capex allocated to the FR business; the remainder is assigned to PZU trading.",
    )

    st.markdown("### Operating Cost Assumptions")
    cost_cols = st.columns(2)
    with cost_cols[0]:
        fr_operating_cost_annual = st.number_input(
            "FR operating cost (€/year)",
            min_value=0.0,
            value=default_fr_opex,
            step=25_000.0,
        )
    with cost_cols[1]:
        pzu_operating_cost_annual = st.number_input(
            "PZU operating cost (€/year)",
            min_value=0.0,
            value=default_pzu_opex,
            step=25_000.0,
        )

    equity_ratio = equity_pct / 100.0
    interest_rate = interest_rate_pct / 100.0
    fr_investment = total_investment * (investment_split_pct / 100.0)
    pzu_investment = total_investment - fr_investment
    fr_equity = fr_investment * equity_ratio
    pzu_equity = pzu_investment * equity_ratio
    fr_debt = fr_investment - fr_equity
    pzu_debt = pzu_investment - pzu_equity

    def _annuity_payment(principal: float, rate: float, periods: int) -> float:
        if principal <= 0 or periods <= 0:
            return 0.0
        if rate <= 0:
            return principal / periods
        factor = (1 + rate) ** periods
        return principal * rate * factor / (factor - 1)

    fr_annual_debt_service = _annuity_payment(fr_debt, interest_rate, loan_term_years)
    pzu_annual_debt_service = _annuity_payment(pzu_debt, interest_rate, loan_term_years)
    monthly_fr_opex = -fr_operating_cost_annual / 12.0 if fr_operating_cost_annual else 0.0
    monthly_pzu_opex = -pzu_operating_cost_annual / 12.0 if pzu_operating_cost_annual else 0.0
    monthly_fr_debt = -fr_annual_debt_service / 12.0 if fr_annual_debt_service else 0.0
    monthly_pzu_debt = -pzu_annual_debt_service / 12.0 if pzu_annual_debt_service else 0.0

    annual_fr = fr_metrics.get("annual", {})
    fr_gross_revenue = float(annual_fr.get("total", 0.0))
    fr_energy_cost = float(annual_fr.get("energy_cost", 0.0))
    fr_base_net = float(annual_fr.get("net", 0.0))
    fr_net_after_opex = fr_base_net - fr_operating_cost_annual
    fr_net_after_debt = fr_net_after_opex - fr_annual_debt_service

    daily_history_raw = pzu_metrics.get("daily_history")
    pzu_df = pd.DataFrame(daily_history_raw) if isinstance(daily_history_raw, list) and daily_history_raw else pd.DataFrame()
    pzu_base_net = 0.0
    if not pzu_df.empty and "daily_profit_eur" in pzu_df.columns:
        pzu_base_net = float(pzu_df["daily_profit_eur"].sum()) / max(len(pzu_df), 1) * 365.0
    pzu_net_after_opex = pzu_base_net - pzu_operating_cost_annual
    pzu_net_after_debt = pzu_net_after_opex - pzu_annual_debt_service

    st.markdown("### Financing Summary")
    summary_cols = st.columns(2)
    with summary_cols[0]:
        st.markdown("**Frequency Regulation (FR)**")
        st.metric("Investment", format_currency(fr_investment, decimals=0))
        st.metric("Equity", format_currency(fr_equity, decimals=0))
        st.metric("Debt principal", format_currency(fr_debt, decimals=0))
        st.metric("Annual debt service", format_currency(fr_annual_debt_service, decimals=0))
        st.metric("Net after debt", format_currency(fr_net_after_debt, decimals=0))
    with summary_cols[1]:
        st.markdown("**PZU Trading**")
        st.metric("Investment", format_currency(pzu_investment, decimals=0))
        st.metric("Equity", format_currency(pzu_equity, decimals=0))
        st.metric("Debt principal", format_currency(pzu_debt, decimals=0))
        st.metric("Annual debt service", format_currency(pzu_annual_debt_service, decimals=0))
        st.metric("Net after debt", format_currency(pzu_net_after_debt, decimals=0))

    st.markdown("### Operating Performance")
    perf_cols = st.columns(2)
    with perf_cols[0]:
        st.metric("FR revenue", format_currency(fr_gross_revenue, decimals=0))
        st.metric("FR energy cost", format_currency(fr_energy_cost, decimals=0))
        st.metric("FR operating cost", format_currency(fr_operating_cost_annual, decimals=0))
        st.metric("FR net after opex", format_currency(fr_net_after_opex, decimals=0))
    with perf_cols[1]:
        st.metric("PZU gross profit", format_currency(pzu_base_net, decimals=0))
        st.metric("PZU operating cost", format_currency(pzu_operating_cost_annual, decimals=0))
        st.metric("PZU net after opex", format_currency(pzu_net_after_opex, decimals=0))

    raw_fr_months = fr_metrics.get("months") if isinstance(fr_metrics, dict) else None
    fr_months_df = pd.DataFrame(raw_fr_months) if isinstance(raw_fr_months, list) and raw_fr_months else pd.DataFrame()

    if not fr_months_df.empty:
        if "month" in fr_months_df.columns:
            try:
                fr_months_df["month_period"] = pd.PeriodIndex(fr_months_df["month"], freq="M")
            except Exception:
                fr_months_df["month_period"] = pd.to_datetime(fr_months_df["month"], errors="coerce").dt.to_period("M")
        elif "month_period" in fr_months_df.columns:
            fr_months_df["month_period"] = pd.PeriodIndex(fr_months_df["month_period"], freq="M")
        else:
            fr_months_df["month_period"] = pd.to_datetime(fr_months_df.index, errors="coerce").to_series().dt.to_period("M")
        fr_months_df = fr_months_df.dropna(subset=["month_period"]).sort_values("month_period")

    pzu_monthly = pd.DataFrame()
    if not pzu_df.empty and "date" in pzu_df.columns:
        pzu_df["date"] = pd.to_datetime(pzu_df["date"], errors="coerce")
        pzu_df = pzu_df.dropna(subset=["date"]).sort_values("date")
        if not pzu_df.empty and "daily_profit_eur" in pzu_df.columns:
            pzu_monthly = (
                pzu_df.assign(month=pzu_df["date"].dt.to_period("M"))
                .groupby("month", as_index=False)["daily_profit_eur"]
                .sum()
                .rename(columns={"daily_profit_eur": "total_profit_eur"})
                .sort_values("month")
            )
            pzu_monthly["month_period"] = pd.PeriodIndex(pzu_monthly["month"], freq="M")

    start_candidates: List[pd.Period] = []
    end_candidates: List[pd.Period] = []
    if not fr_months_df.empty:
        start_candidates.append(fr_months_df["month_period"].min())
        end_candidates.append(fr_months_df["month_period"].max())
    if not pzu_monthly.empty:
        start_candidates.append(pzu_monthly["month_period"].min())
        end_candidates.append(pzu_monthly["month_period"].max())

    range_start = min(start_candidates) if start_candidates else None
    range_end = max(end_candidates) if end_candidates else None

    if not fr_months_df.empty:
        fr_months_df = backfill_fr_monthly_dataframe(fr_months_df, start_period=range_start, end_period=range_end)
    if not pzu_monthly.empty and range_start is not None and range_end is not None:
        monthly_index = pd.period_range(range_start, range_end, freq="M")
        pzu_monthly = pzu_monthly.set_index("month_period").reindex(monthly_index)
        pzu_monthly["total_profit_eur"] = pd.to_numeric(pzu_monthly["total_profit_eur"], errors="coerce")
        if pzu_monthly["total_profit_eur"].notna().any():
            pzu_monthly["total_profit_eur"] = pzu_monthly["total_profit_eur"].fillna(pzu_monthly["total_profit_eur"].mean())
        else:
            pzu_monthly["total_profit_eur"] = 0.0
        pzu_monthly = pzu_monthly.reset_index().rename(columns={"index": "month_period"})
        pzu_monthly["month"] = pzu_monthly["month_period"].astype(str)

    fr_months_idx = fr_months_df.set_index("month_period") if not fr_months_df.empty else pd.DataFrame()
    pzu_months_idx = pzu_monthly.set_index("month_period") if not pzu_monthly.empty else pd.DataFrame()

    all_periods: List[pd.Period] = sorted(
        set(fr_months_idx.index.to_list() if not fr_months_idx.empty else [])
        | set(pzu_months_idx.index.to_list() if not pzu_months_idx.empty else [])
    )

    def _fill_mean(series: pd.Series) -> pd.Series:
        series = pd.to_numeric(series, errors="coerce")
        if series.notna().any():
            return series.fillna(series.mean())
        return series.fillna(0.0)

    if all_periods:
        if fr_months_idx.empty:
            fr_months_idx = pd.DataFrame(index=pd.Index(all_periods, name="month_period"))
        else:
            fr_months_idx = fr_months_idx.reindex(all_periods)
        for col in ["capacity_revenue_eur", "activation_revenue_eur", "total_revenue_eur", "energy_cost_eur"]:
            if col not in fr_months_idx.columns:
                fr_months_idx[col] = np.nan
            fr_months_idx[col] = _fill_mean(fr_months_idx[col])
        if "total_revenue_eur" not in fr_months_idx.columns or fr_months_idx["total_revenue_eur"].isna().all():
            fr_months_idx["total_revenue_eur"] = fr_months_idx.get("capacity_revenue_eur", 0.0) + fr_months_idx.get("activation_revenue_eur", 0.0)
        fr_months_idx["net_before_debt"] = (
            fr_months_idx["total_revenue_eur"].fillna(0.0) - fr_months_idx["energy_cost_eur"].fillna(0.0) + monthly_fr_opex
        )

        if pzu_months_idx.empty:
            pzu_months_idx = pd.DataFrame(index=pd.Index(all_periods, name="month_period"))
        else:
            pzu_months_idx = pzu_months_idx.reindex(all_periods)
        pzu_months_idx["net_before_debt"] = _fill_mean(pzu_months_idx.get("total_profit_eur", 0.0)) + monthly_pzu_opex

    loan_term_months = loan_term_years * 12

    def build_cashflow_tables(monthly_series: pd.Series, monthly_debt_share: float, equity: float):
        rows: List[Dict[str, object]] = []
        cumulative = -equity
        rows.append(
            {
                "Period": None,
                "Month": "Initial",
                "Net before debt €": 0.0,
                "Debt service €": 0.0,
                "Net after debt €": -equity,
                "Cumulative €": cumulative,
            }
        )
        # Process historical data months
        historical_months_count = 0
        if isinstance(monthly_series, pd.Series) and not monthly_series.empty:
            monthly_series = pd.to_numeric(monthly_series, errors="coerce").fillna(0.0).sort_index()
            for idx, (period, value) in enumerate(monthly_series.items(), start=1):
                debt = monthly_debt_share if idx <= loan_term_months else 0.0
                net_after_debt = float(value) + debt
                cumulative += net_after_debt
                rows.append(
                    {
                        "Period": period,
                        "Month": str(period),
                        "Net before debt €": float(value),
                        "Debt service €": debt,
                        "Net after debt €": net_after_debt,
                        "Cumulative €": cumulative,
                    }
                )
                historical_months_count = idx

        # CRITICAL FIX: Extend debt payments beyond historical data window
        # If loan term exceeds historical period, add remaining debt-only months
        if historical_months_count < loan_term_months:
            remaining_months = loan_term_months - historical_months_count
            last_period = monthly_series.index[-1] if not monthly_series.empty else None

            for remaining_idx in range(1, remaining_months + 1):
                month_number = historical_months_count + remaining_idx
                # Project future period (approximate)
                if last_period:
                    future_period = last_period + remaining_idx
                    period_str = str(future_period)
                else:
                    period_str = f"Month {month_number}"

                # No operating revenue beyond historical data, only debt service
                debt = monthly_debt_share
                net_after_debt = debt  # Negative (debt payment only)
                cumulative += net_after_debt

                rows.append(
                    {
                        "Period": None,  # No period object for projected months
                        "Month": f"{period_str} (projected)",
                        "Net before debt €": 0.0,
                        "Debt service €": debt,
                        "Net after debt €": net_after_debt,
                        "Cumulative €": cumulative,
                    }
                )

        monthly_df = pd.DataFrame(rows)
        display_monthly = monthly_df.drop(columns=["Period"]).copy()
        for col in ["Net before debt €", "Debt service €", "Net after debt €", "Cumulative €"]:
            display_monthly[col] = display_monthly[col].apply(lambda v: format_currency(v, decimals=0))

        yearly_rows: List[Dict[str, object]] = [
            {
                "Year": 0,
                "Net before debt €": 0.0,
                "Debt service €": 0.0,
                "Net after debt €": -equity,
                "Cumulative €": -equity,
            }
        ]

        monthly_calc = monthly_df.dropna(subset=["Period"]).copy()
        if not monthly_calc.empty:
            monthly_calc["Year"] = monthly_calc["Period"].apply(lambda p: int(p.year) if isinstance(p, pd.Period) else None)
            yearly_group = (
                monthly_calc.groupby("Year")[["Net before debt €", "Debt service €", "Net after debt €"]]
                .sum()
                .reset_index()
                .sort_values("Year")
            )
            cumulative_year = -equity
            for _, row in yearly_group.iterrows():
                net_after = float(row["Net after debt €"])
                cumulative_year += net_after
                yearly_rows.append(
                    {
                        "Year": int(row["Year"]),
                        "Net before debt €": float(row["Net before debt €"]),
                        "Debt service €": float(row["Debt service €"]),
                        "Net after debt €": net_after,
                        "Cumulative €": cumulative_year,
                    }
                )

        yearly_df = pd.DataFrame(yearly_rows)
        display_yearly = yearly_df.copy()
        for col in ["Net before debt €", "Debt service €", "Net after debt €", "Cumulative €"]:
            display_yearly[col] = display_yearly[col].apply(lambda v: format_currency(v, decimals=0))

        payback_year = next((row["Year"] for row in yearly_rows if row["Year"] and row["Cumulative €"] >= 0), None)
        total_net_after_debt = sum(row["Net after debt €"] for row in yearly_rows if row["Year"])
        roi = (total_net_after_debt / equity) if equity > 0 else 0.0

        # Calculate data coverage vs loan term
        data_months = historical_months_count
        data_coverage_pct = (data_months / loan_term_months * 100) if loan_term_months > 0 else 100

        return display_monthly, display_yearly, payback_year, roi, data_coverage_pct

    fr_series = fr_months_idx["net_before_debt"] if not fr_months_idx.empty and "net_before_debt" in fr_months_idx else pd.Series(dtype=float)
    pzu_series = pzu_months_idx["net_before_debt"] if not pzu_months_idx.empty and "net_before_debt" in pzu_months_idx else pd.Series(dtype=float)

    fr_monthly_display, fr_yearly_display, fr_payback_year, fr_roi, fr_data_coverage = build_cashflow_tables(fr_series, monthly_fr_debt, fr_equity)
    pzu_monthly_display, pzu_yearly_display, pzu_payback_year, pzu_roi, pzu_data_coverage = build_cashflow_tables(pzu_series, monthly_pzu_debt, pzu_equity)

    # Warn if loan term exceeds data window
    if fr_data_coverage < 100:
        st.warning(
            f"⚠️ FR: Loan term ({loan_term_years} years) exceeds historical data period "
            f"({fr_data_coverage:.0f}% coverage). Remaining {100-fr_data_coverage:.0f}% of debt payments "
            f"projected with no operating revenue (conservative estimate)."
        )

    if pzu_data_coverage < 100:
        st.warning(
            f"⚠️ PZU: Loan term ({loan_term_years} years) exceeds historical data period "
            f"({pzu_data_coverage:.0f}% coverage). Remaining {100-pzu_data_coverage:.0f}% of debt payments "
            f"projected with no operating revenue (conservative estimate)."
        )

    st.markdown("### FR Cashflow")
    if not fr_monthly_display.empty:
        fr_view = st.radio("FR table view", ["Monthly", "Yearly"], key="fr_cashflow_view")
        if fr_view == "Monthly":
            st.dataframe(fr_monthly_display, width="stretch")
        else:
            st.dataframe(fr_yearly_display, width="stretch")
    else:
        st.info("FR monthly cashflow data unavailable; run the FR Simulator for historical periods.")

    st.markdown("### PZU Cashflow")
    if not pzu_monthly_display.empty:
        pzu_view = st.radio("PZU table view", ["Monthly", "Yearly"], key="pzu_cashflow_view")
        if pzu_view == "Monthly":
            st.dataframe(pzu_monthly_display, width="stretch")
        else:
            st.dataframe(pzu_yearly_display, width="stretch")
    else:
        st.info("PZU monthly cashflow data unavailable; run the PZU Horizons analysis for historical periods.")

    st.markdown("### Payback & ROI")
    payback_cols = st.columns(2)
    with payback_cols[0]:
        st.markdown("**FR**")
        st.metric("Payback year", "—" if fr_payback_year is None else fr_payback_year)
        st.metric("ROI", "—" if fr_equity <= 0 else f"{fr_roi * 100:.1f}%")
    with payback_cols[1]:
        st.markdown("**PZU**")
        st.metric("Payback year", "—" if pzu_payback_year is None else pzu_payback_year)
        st.metric("ROI", "—" if pzu_equity <= 0 else f"{pzu_roi * 100:.1f}%")



view = st.radio(
    "View",
    options=[
        "PZU Horizons",
        "FR Simulator",
        "Romanian BM",
        "Market Comparison",
        "FR Energy Hedging",
        "Investment & Financing",
    ],
    horizontal=True,
)

history_start: Optional[pd.Timestamp] = None
history_end: Optional[pd.Timestamp] = None
earliest_available_ts: Optional[pd.Timestamp] = None
latest_available_ts: Optional[pd.Timestamp] = None

with st.sidebar:
    st.header("Configuration")
    cfg_path = st.text_input("Config file", value="config.yaml", help="Path to YAML settings")
    if not Path(cfg_path).exists():
        st.error("config.yaml not found. Adjust the path.")
        st.stop()
    cfg = load_config(cfg_path)
    tz = cfg["execution"]["timezone"]

    # Data sources
    with st.expander("Data Sources", expanded=True):
        default_pzu_csv = cfg["data"].get("pzu_forecast_csv")
        default_bm_csv = cfg["data"].get("bm_forecast_csv")
        pzu_csv_override = st.text_input("PZU history CSV", value=default_pzu_csv or "", help="At least 3 years for robust stats")
        bm_csv_override = st.text_input("BM history CSV", value=default_bm_csv or "")
        provider = DataProvider(pzu_csv=pzu_csv_override or default_pzu_csv, bm_csv=bm_csv_override or default_bm_csv)
        if provider.pzu_csv and not Path(provider.pzu_csv).exists():
            st.warning(f"PZU CSV not found: {provider.pzu_csv}")
        if provider.bm_csv and not Path(provider.bm_csv).exists():
            st.warning(f"Balancing CSV not found: {provider.bm_csv}")

        bm_dates: List[str] = []
        if provider.bm_csv and Path(provider.bm_csv).exists():
            try:
                df_bm_dates = pd.read_csv(provider.bm_csv, usecols=["date"]).dropna()
                bm_dates = sorted(df_bm_dates["date"].astype(str).unique().tolist())
            except Exception:
                bm_dates = []

        pzu_dates: List[str] = []
        if provider.pzu_csv and Path(provider.pzu_csv).exists():
            try:
                df_pzu_dates = pd.read_csv(provider.pzu_csv, usecols=["date"]).dropna()
                pzu_dates = sorted(df_pzu_dates["date"].astype(str).unique().tolist())
            except Exception:
                pzu_dates = []

        available_dates = pzu_dates or bm_dates
        default_date = datetime.fromisoformat((pzu_dates[-1] if pzu_dates else available_dates[-1])).date() if available_dates else date.today()
        min_date = datetime.fromisoformat((pzu_dates[0] if pzu_dates else available_dates[0])).date() if available_dates else None
        max_date = default_date
        chosen_date = st.date_input(
            "Target date",
            value=default_date,
            min_value=min_date,
            max_value=max_date,
            help="Used for balancing-market daily charts.",
        )
        if min_date:
            earliest_available_ts = pd.Timestamp(min_date)
        if max_date:
            latest_available_ts = pd.Timestamp(max_date)

        history_options = [
            "Full history",
            "Last 12 months",
            "Last 24 months",
            "Last 36 months",
            "Custom start date",
            "Custom years range",
        ]
        history_choice = st.selectbox(
            "History window for profitability analysis",
            history_options,
            index=0,
        )

        history_start = None
        history_end = None
        latest_available_ts = None
        if available_dates:
            available_ts = pd.to_datetime(available_dates, errors="coerce")
            available_ts = available_ts.dropna()
            if not available_ts.empty:
                earliest_available_ts = available_ts.min()
                latest_available_ts = available_ts.max()
        if latest_available_ts is None:
            latest_available_ts = pd.Timestamp(date.today())
        if earliest_available_ts is None:
            earliest_available_ts = latest_available_ts

        if history_choice == "Full history":
            history_start = earliest_available_ts
            history_end = latest_available_ts
        elif history_choice == "Last 12 months":
            history_start = latest_available_ts - pd.DateOffset(months=12)
        elif history_choice == "Last 24 months":
            history_start = latest_available_ts - pd.DateOffset(months=24)
        elif history_choice == "Last 36 months":
            history_start = latest_available_ts - pd.DateOffset(months=36)
        elif history_choice == "Custom start date":
            default_start = latest_available_ts - pd.DateOffset(months=12)
            custom_start_input = st.date_input(
                "Select custom start date",
                value=default_start.date(),
                help="Only data on or after this date will be used for cycle calculations.",
            )
            history_start = pd.Timestamp(custom_start_input)
        elif history_choice == "Custom years range":
            min_year = int(available_dates[0][:4]) if available_dates else 2020
            max_year = int(available_dates[-1][:4]) if available_dates else latest_available_ts.year
            col_a, col_b = st.columns(2)
            start_year = col_a.number_input("Start year", min_value=min_year, max_value=max_year, value=min_year)
            end_year = col_b.number_input("End year", min_value=start_year, max_value=max_year, value=max_year)
            history_start = pd.Timestamp(year=int(start_year), month=1, day=1)
            history_end = pd.Timestamp(year=int(end_year), month=12, day=31)

    with st.expander("Battery", expanded=True):
        capacity_default = float(cfg["battery"]["capacity_mwh"])
        power_default = float(cfg["battery"]["power_mw"])
        soc_initial = float(cfg["battery"]["soc_initial"])  # [0..1]
        eta_rt = float(cfg["battery"]["round_trip_efficiency"])  # [0..1]
        capacity_mwh = capacity_default
        power_mw = power_default
        st.caption(
            "Defaults come from config.yaml. Use the controls above the PZU Horizons view to experiment with alternative capacity/power values."
        )

    auto_run = st.checkbox("Auto run (recompute on change)", value=True)
    run_btn = auto_run or st.button("Run Analysis")

    # Display options
    with st.expander("Display", expanded=False):
        currency_decimals = st.slider("Currency decimals", 0, 2, 0)
        percent_decimals = st.slider("Percent decimals", 0, 2, 1)
        float_decimals = st.slider("Float decimals", 0, 4, 2)
        thousands_sep = st.checkbox("Thousands separator", value=True)
        show_raw_tables = st.checkbox("Show raw numeric tables", value=False, help="If on, tables are unformatted for sorting")

if view == "PZU Horizons":
    st.subheader("PZU Profitability Horizons")

    control_cols = st.columns(2)
    capacity_mwh = control_cols[0].number_input(
        "Capacity (MWh)",
        min_value=1.0,
        value=float(capacity_mwh),
        step=1.0,
        key="pzu_horizon_capacity",
    )
    power_mw = control_cols[1].number_input(
        "Power (MW)",
        min_value=0.1,
        value=float(power_mw),
        step=0.5,
        key="pzu_horizon_power",
    )

    date_cols = st.columns(2)
    start_default_ts = history_start or earliest_available_ts or pd.Timestamp(date.today())
    end_default_ts = history_end or latest_available_ts or pd.Timestamp(date.today())
    start_input = date_cols[0].date_input(
        "Start date (inclusive)",
        value=start_default_ts.to_pydatetime().date(),
        min_value=(earliest_available_ts or start_default_ts).to_pydatetime().date(),
        max_value=(latest_available_ts or end_default_ts).to_pydatetime().date(),
        key="pzu_horizon_start",
    )
    end_input = date_cols[1].date_input(
        "End date (inclusive)",
        value=end_default_ts.to_pydatetime().date(),
        min_value=start_input,
        max_value=(latest_available_ts or end_default_ts).to_pydatetime().date(),
        key="pzu_horizon_end",
    )
    history_start = pd.Timestamp(start_input)
    history_end = pd.Timestamp(end_input)
    if history_start > history_end:
        st.warning("Start date is after end date; swapping them.")
        history_start, history_end = history_end, history_start
    if history_start is not None and history_end is not None:
        st.caption(
            f"Analysis window: {history_start.strftime('%Y-%m-%d')} → {history_end.strftime('%Y-%m-%d')}"
        )
    else:
        st.caption("Analysis window: full available history")

if run_btn:
    load_pzu_params = {
        "pzu_csv": provider.pzu_csv,
        "capacity_mwh": capacity_mwh,
        "round_trip_efficiency": eta_rt,
        "power_mw": power_mw,
    }
    sig_load = inspect.signature(load_pzu_daily_history)
    if "start_date" in sig_load.parameters:
        load_pzu_params["start_date"] = history_start
    if "end_date" in sig_load.parameters:
        load_pzu_params["end_date"] = history_end

    daily_history = load_pzu_daily_history(**load_pzu_params)
    horizon_summaries = []
    bm_series = load_balancing_day_series(provider.bm_csv, chosen_date.isoformat())

    fixed_params = {
        "pzu_csv": provider.pzu_csv,
        "capacity_mwh": capacity_mwh,
        "power_mw": power_mw,
        "round_trip_efficiency": eta_rt,
    }
    sig_fixed = inspect.signature(compute_best_fixed_cycle)
    if "start_date" in sig_fixed.parameters:
        fixed_params["start_date"] = history_start
    if "end_date" in sig_fixed.parameters:
        fixed_params["end_date"] = history_end

    fixed_cycle = compute_best_fixed_cycle(**fixed_params)
    fixed_history: pd.DataFrame = fixed_cycle.get("daily_history", pd.DataFrame())
    fixed_summaries = summarize_profit_windows(fixed_history) if not fixed_history.empty else []

    if view == "PZU Horizons":
        fixed_params = {
            "pzu_csv": provider.pzu_csv,
            "capacity_mwh": capacity_mwh,
            "power_mw": power_mw,
            "round_trip_efficiency": eta_rt,
        }
        sig_fixed = inspect.signature(compute_best_fixed_cycle)
        if "start_date" in sig_fixed.parameters:
            fixed_params["start_date"] = history_start
        if "end_date" in sig_fixed.parameters:
            fixed_params["end_date"] = history_end

        fixed_cycle = compute_best_fixed_cycle(**fixed_params)
        fixed_history: pd.DataFrame = fixed_cycle.get("daily_history", pd.DataFrame())
        fixed_summaries = summarize_profit_windows(fixed_history) if not fixed_history.empty else []

        if fixed_history.empty:
            st.info("No historical PZU data available at the configured path.")
        else:
            start_dt = fixed_history['date'].iloc[0]
            end_dt = fixed_history['date'].iloc[-1]
            st.caption(
                f"History coverage: {start_dt.strftime('%Y-%m-%d')} → {end_dt.strftime('%Y-%m-%d')}"
                f" | {len(fixed_history)} full days"
            )

            price_series = load_pzu_price_series(
                provider.pzu_csv,
                start_date=history_start,
                end_date=history_end,
            )
            if not price_series.empty:
                st.line_chart(
                    price_series.set_index("date")["avg_price_eur_mwh"],
                    height=260,
                )
                st.caption("Average PZU price per day over the selected window.")

            st.subheader("Best Fixed 2h Cycle (historical across all days)")
            st.caption(
                "This summary finds the single 2-hour charge and discharge block that performs best over the selected window using the current capacity and power."
            )
            
            buy_hour = fixed_cycle.get("buy_start_hour")
            sell_hour = fixed_cycle.get("sell_start_hour")
            if buy_hour is None or sell_hour is None:
                st.info("Not enough consistent history to determine a fixed 2h schedule.")
            else:
                # Enrich stats first
                stats = enrich_cycle_stats(fixed_cycle.get("stats", {}), fixed_history)
                
                # Calculate key metrics for indicators
                total_profit = stats.get("total_profit_eur", 0.0)
                total_days = stats.get("total_days", 1)
                positive_days = stats.get("positive_days", 0)
                win_rate = (positive_days / total_days * 100) if total_days > 0 else 0.0
                spread = stats.get("spread_eur_mwh", 0.0)
                
                # Get status indicators
                profit_indicator = get_status_indicator(total_profit, "profit")
                win_rate_indicator = get_status_indicator(win_rate, "win_rate")
                spread_indicator = get_status_indicator(spread, "spread")
                
                # ===== SCHEDULE OVERVIEW CONTAINER =====
                st.markdown("### 📅 Optimal Schedule")
                buy_end = min(int(buy_hour) + 2, 24)
                sell_end = min(int(sell_hour) + 2, 24)
                
                schedule_cols = st.columns(4)
                with schedule_cols[0]:
                    st.metric(
                        "⚡ Charge Window",
                        f"{int(buy_hour):02d}:00–{buy_end:02d}:00",
                        help="Optimal 2-hour charging period (lowest prices)"
                    )
                with schedule_cols[1]:
                    st.metric(
                        "🔋 Discharge Window", 
                        f"{int(sell_hour):02d}:00–{sell_end:02d}:00",
                        help="Optimal 2-hour discharging period (highest prices)"
                    )
                with schedule_cols[2]:
                    st.metric(
                        "📥 Charge Energy",
                        f"{fixed_cycle['charge_energy_mwh']:.1f} MWh",
                        help="Total energy absorbed during charging"
                    )
                with schedule_cols[3]:
                    st.metric(
                        "📤 Discharge Energy",
                        f"{fixed_cycle['discharge_energy_mwh']:.1f} MWh",
                        help="Total energy delivered during discharging"
                    )

                # ===== FINANCIAL PERFORMANCE CONTAINER =====
                st.markdown("### 💰 Financial Performance")
                price_decimals = max(currency_decimals, 2)

                # Save metrics for session state
                try:
                    daily_history_subset = fixed_history[
                        [
                            "date",
                            "daily_profit_eur",
                            "daily_revenue_eur",
                            "daily_cost_eur",
                        ]
                    ].copy()
                    history_start_val = sanitize_session_value(history_start)
                    history_end_val = sanitize_session_value(history_end)
                    stats_clean = sanitize_session_value(stats)
                    daily_history_records = sanitize_session_value(
                        daily_history_subset.to_dict(orient="records")
                    )
                    new_pzu_metrics = {
                        "history_start": history_start_val,
                        "history_end": history_end_val,
                        "stats": stats_clean,
                        "daily_history": daily_history_records,
                    }
                    safe_session_state_update("pzu_market_metrics", new_pzu_metrics)
                except Exception:
                    pass

                # Main financial metrics with status indicators
                fin_cols = st.columns(4)
                with fin_cols[0]:
                    st.metric(
                        f"{profit_indicator} Total Profit",
                        format_currency(total_profit, decimals=currency_decimals, thousands=thousands_sep),
                        help="Total profit over the analysis period"
                    )
                with fin_cols[1]:
                    st.metric(
                        "📊 Average Daily",
                        format_currency(stats.get("average_profit_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
                        help="Average daily profit"
                    )
                with fin_cols[2]:
                    st.metric(
                        "📈 Total Revenue",
                        format_currency(stats.get("total_revenue_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
                        help="Total revenue from energy sales"
                    )
                with fin_cols[3]:
                    st.metric(
                        "📉 Total Cost",
                        format_currency(stats.get("total_cost_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
                        help="Total cost of energy purchases"
                    )

                # ===== PRICE ANALYSIS CONTAINER =====
                st.markdown("### 📊 Price Analysis & Spreads")
                price_cols = st.columns(4)
                with price_cols[0]:
                    st.metric(
                        "💰 Avg Sell Price",
                        format_price_per_mwh(stats.get("avg_sell_price_eur_mwh"), decimals=price_decimals),
                        help="Average price received when selling energy"
                    )
                with price_cols[1]:
                    st.metric(
                        "💵 Avg Buy Price",
                        format_price_per_mwh(stats.get("avg_buy_price_eur_mwh"), decimals=price_decimals),
                        help="Average price paid when buying energy"
                    )
                with price_cols[2]:
                    st.metric(
                        f"{spread_indicator} Spread",
                        format_price_per_mwh(spread, decimals=price_decimals),
                        help="Average price spread (sell - buy)"
                    )
                with price_cols[3]:
                    st.metric(
                        f"{win_rate_indicator} Win Rate",
                        f"{win_rate:.1f}%",
                        help=f"{positive_days} profitable days out of {total_days}"
                    )

                # ===== SUCCESS METRICS CONTAINER =====
                st.markdown("### 📈 Success Metrics")
                success_cols = st.columns(4)
                with success_cols[0]:
                    st.metric(
                        "✅ Winning Days", 
                        f"{positive_days}/{total_days}",
                        help="Days with positive profit"
                    )
                with success_cols[1]:
                    negative_days = stats.get("negative_days", 0)
                    st.metric(
                        "❌ Losing Days", 
                        f"{negative_days}/{total_days}",
                        help="Days with negative profit"
                    )
                with success_cols[2]:
                    st.metric(
                        "💸 Total Loss",
                        format_currency(stats.get("total_loss_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
                        help="Sum of all losses on losing days"
                    )
                with success_cols[3]:
                    avg_loss = stats.get("total_loss_eur", 0.0) / negative_days if negative_days > 0 else 0.0
                    st.metric(
                        "📉 Avg Loss/Day",
                        format_currency(avg_loss, decimals=currency_decimals, thousands=thousands_sep),
                        help="Average loss per losing day"
                    )

                # ===== SUMMARY TABLES =====
                st.markdown("---")
                st.markdown("### 📋 Detailed Analysis")
                
                # Profit windows summary
                if fixed_summaries:
                    st.markdown("#### Historical Profitability Windows")
                    summary_rows = []
                    for window in fixed_summaries:
                        period = window.get("period_label", "Unknown")
                        profit = window.get("total_profit_eur", 0.0)
                        days = window.get("days", 0)
                        avg_daily = window.get("avg_profit_eur", 0.0)
                        win_pct = window.get("win_rate_percent", 0.0)
                        
                        indicator = get_status_indicator(profit, "profit")
                        win_indicator = get_status_indicator(win_pct, "win_rate")
                        
                        summary_rows.append({
                            "Period": f"{indicator} {period}",
                            "Days": days,
                            "Total Profit": format_currency(profit, decimals=currency_decimals, thousands=thousands_sep),
                            "Avg Daily": format_currency(avg_daily, decimals=currency_decimals, thousands=thousands_sep),
                            "Win Rate": f"{win_indicator} {win_pct:.1f}%"
                        })
                    
                    if summary_rows:
                        st.dataframe(pd.DataFrame(summary_rows), use_container_width=True, hide_index=True)
                
                # Cash flow summary
                cash_flow_3y = build_cash_flow_summary(fixed_history, years=3, freq="Y")
                if not cash_flow_3y.empty:
                    st.markdown("#### Annual Cash Flow (Last 3 Years)")
                    
                    # Format the cash flow table with indicators
                    display_cf = cash_flow_3y.copy()
                    for idx, row in display_cf.iterrows():
                        if row.get("Year") != "Total":
                            profit = cash_flow_3y.loc[idx, "Profit €"]
                            if pd.notna(profit):
                                indicator = get_status_indicator(profit, "profit")
                                display_cf.loc[idx, "Year"] = f"{indicator} {row['Year']}"
                    
                    # Format currency columns
                    for col in ["Turnover €", "Cost €", "Profit €", "Loss €"]:
                        if col in display_cf.columns:
                            display_cf[col] = display_cf[col].apply(
                                lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep) if pd.notna(v) else "—"
                            )
                    
                    # Format price columns
                    for col in ["Avg buy €/MWh", "Avg sell €/MWh", "Spread €/MWh"]:
                        if col in display_cf.columns:
                            display_cf[col] = display_cf[col].apply(
                                lambda v: format_price_per_mwh(v, decimals=price_decimals) if pd.notna(v) else "—"
                            )
                    
                    st.dataframe(display_cf, use_container_width=True, hide_index=True)

        st.subheader("Custom Fixed 2h Scenario")
        st.caption("Adjust capacity, power and date range to evaluate a separate fixed 2‑hour schedule without altering the main view above.")

        scenario_cols = st.columns(2)
        scenario_capacity = scenario_cols[0].number_input(
            "Scenario capacity (MWh)",
            min_value=1.0,
            value=float(capacity_mwh),
            step=1.0,
            key="scenario_capacity",
        )
        scenario_power = scenario_cols[1].number_input(
            "Scenario power (MW)",
            min_value=0.1,
            value=float(power_mw),
            step=0.5,
            key="scenario_power",
        )

        scenario_date_cols = st.columns(2)
        scenario_min = (earliest_available_ts or history_start or pd.Timestamp(date.today())).to_pydatetime().date()
        scenario_max = (latest_available_ts or history_end or pd.Timestamp(date.today())).to_pydatetime().date()
        scenario_start_input = scenario_date_cols[0].date_input(
            "Scenario start",
            value=(history_start or earliest_available_ts or pd.Timestamp(date.today())).to_pydatetime().date(),
            min_value=scenario_min,
            max_value=scenario_max,
            key="scenario_start",
        )
        scenario_end_input = scenario_date_cols[1].date_input(
            "Scenario end",
            value=(history_end or latest_available_ts or pd.Timestamp(date.today())).to_pydatetime().date(),
            min_value=scenario_start_input,
            max_value=scenario_max,
            key="scenario_end",
        )

        scenario_start_ts = pd.Timestamp(scenario_start_input)
        scenario_end_ts = pd.Timestamp(scenario_end_input)
        if scenario_start_ts > scenario_end_ts:
            scenario_start_ts, scenario_end_ts = scenario_end_ts, scenario_start_ts

        scenario_cycle = compute_best_fixed_cycle(
            provider.pzu_csv,
            capacity_mwh=scenario_capacity,
            power_mw=scenario_power,
            round_trip_efficiency=eta_rt,
            start_date=scenario_start_ts,
            end_date=scenario_end_ts,
        )

        scenario_history = scenario_cycle.get("daily_history", pd.DataFrame())
        if scenario_history.empty:
            st.info("No scenario results available for the selected period.")
        else:
            scenario_prices = load_pzu_price_series(
                provider.pzu_csv,
                start_date=scenario_start_ts,
                end_date=scenario_end_ts,
            )
            if not scenario_prices.empty:
                st.line_chart(
                    scenario_prices.set_index("date")["avg_price_eur_mwh"],
                    height=240,
                )
                st.caption("Average PZU price per day for the scenario window.")

            scenario_buy = scenario_cycle.get("buy_start_hour")
            scenario_sell = scenario_cycle.get("sell_start_hour")
            if scenario_buy is not None and scenario_sell is not None:
                scenario_buy_end = min(int(scenario_buy) + 2, 24)
                scenario_sell_end = min(int(scenario_sell) + 2, 24)
                sc_cols = st.columns(4)
                sc_cols[0].metric("Charge window", f"{int(scenario_buy):02d}:00–{scenario_buy_end:02d}:00")
                sc_cols[1].metric("Discharge window", f"{int(scenario_sell):02d}:00–{scenario_sell_end:02d}:00")
                sc_cols[2].metric("Charge energy", f"{scenario_cycle['charge_energy_mwh']:.1f} MWh")
                sc_cols[3].metric("Discharge energy", f"{scenario_cycle['discharge_energy_mwh']:.1f} MWh")

            scenario_stats = enrich_cycle_stats(scenario_cycle.get("stats", {}), scenario_history)
            sc_price_decimals = max(currency_decimals, 2)

            sc_stat_cols = st.columns(4)
            sc_stat_cols[0].metric(
                "Total profit",
                format_currency(scenario_stats.get("total_profit_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
            )
            sc_stat_cols[1].metric(
                "Average day",
                format_currency(scenario_stats.get("average_profit_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
            )
            sc_stat_cols[2].metric(
                "Total revenue",
                format_currency(scenario_stats.get("total_revenue_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
            )
            sc_stat_cols[3].metric(
                "Total cost",
                format_currency(scenario_stats.get("total_cost_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
            )

            sc_price_cols = st.columns(3)
            sc_price_cols[0].metric(
                "Avg sell price",
                format_price_per_mwh(scenario_stats.get("avg_sell_price_eur_mwh"), decimals=sc_price_decimals),
            )
            sc_price_cols[1].metric(
                "Avg buy price",
                format_price_per_mwh(scenario_stats.get("avg_buy_price_eur_mwh"), decimals=sc_price_decimals),
            )
            sc_price_cols[2].metric(
                "Spread €/MWh",
                format_price_per_mwh(scenario_stats.get("spread_eur_mwh"), decimals=sc_price_decimals),
            )

            sc_total_days = scenario_stats.get("total_days", 0)
            sc_positive_days = scenario_stats.get("positive_days", 0)
            sc_negative_days = scenario_stats.get("negative_days", 0)
            sc_day_cols = st.columns(3)
            sc_day_cols[0].metric("Winning days", f"{sc_positive_days}/{sc_total_days}")
            sc_day_cols[1].metric("Losing days", f"{sc_negative_days}/{sc_total_days}")
            sc_day_cols[2].metric(
                "Loss on losing days",
                format_currency(scenario_stats.get("total_loss_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
            )

            scenario_summary = summarize_profit_windows(scenario_history)
            if scenario_summary:
                sc_table = []
                for summary in scenario_summary:
                    sc_table.append(
                        {
                            "Period": summary["period_label"],
                            "Days": summary["recent_days"],
                            "Coverage %": summary["coverage_ratio"] * 100 if summary["coverage_ratio"] is not None else None,
                            "Recent total €": summary["recent_total_eur"],
                            "Avg daily €": summary["recent_avg_eur"],
                            "Recent revenue €": summary.get("recent_revenue_eur"),
                            "Recent cost €": summary.get("recent_cost_eur"),
                            "Loss €": summary.get("recent_loss_eur"),
                            "Projected total €": summary.get("projected_total_eur"),
                            "Projected revenue €": summary.get("projected_revenue_eur"),
                            "Projected cost €": summary.get("projected_cost_eur"),
                            "Projected loss €": summary.get("projected_loss_eur"),
                            "Spread €/MWh": summary.get("recent_spread_eur_mwh"),
                            "Win rate %": summary["recent_success_rate"],
                        }
                    )

                sc_df = pd.DataFrame(sc_table)
                preferred_order = [
                    "Period",
                    "Days",
                    "Coverage %",
                    "Recent total €",
                    "Recent revenue €",
                    "Recent cost €",
                    "Loss €",
                    "Projected total €",
                    "Projected revenue €",
                    "Projected cost €",
                    "Projected loss €",
                    "Avg daily €",
                    "Spread €/MWh",
                    "Win rate %",
                ]
                existing_order = [c for c in preferred_order if c in sc_df.columns]
                remaining_cols = [c for c in sc_df.columns if c not in existing_order]
                sc_df = sc_df[existing_order + remaining_cols]
                if show_raw_tables:
                    st.dataframe(sc_df, width='stretch')
                else:
                    sc_display = sc_df.copy()
                    sc_display["Coverage %"] = sc_display["Coverage %"].apply(
                        lambda v: format_percent(v, decimals=percent_decimals) if v is not None else "—"
                    )
                    sc_display["Recent total €"] = sc_display["Recent total €"].apply(
                        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep) if v is not None else "—"
                    )
                    sc_display["Avg daily €"] = sc_display["Avg daily €"].apply(
                        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep) if v is not None else "—"
                    )
                    sc_display["Recent revenue €"] = sc_display["Recent revenue €"].apply(
                        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep) if v is not None else "—"
                    )
                    sc_display["Recent cost €"] = sc_display["Recent cost €"].apply(
                        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep) if v is not None else "—"
                    )
                    sc_display["Loss €"] = sc_display["Loss €"].apply(
                        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep) if v is not None else "—"
                    )
                    sc_display["Projected total €"] = sc_display["Projected total €"].apply(
                        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep) if v is not None else "—"
                    )
                    sc_display["Projected revenue €"] = sc_display["Projected revenue €"].apply(
                        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep) if v is not None else "—"
                    )
                    sc_display["Projected cost €"] = sc_display["Projected cost €"].apply(
                        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep) if v is not None else "—"
                    )
                    sc_display["Projected loss €"] = sc_display["Projected loss €"].apply(
                        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep) if v is not None else "—"
                    )
                    spread_decimals = max(currency_decimals, 2)
                    sc_display["Spread €/MWh"] = sc_display["Spread €/MWh"].apply(
                        lambda v: format_price_per_mwh(v, decimals=spread_decimals) if v is not None else "—"
                    )
                    sc_display["Win rate %"] = sc_display["Win rate %"].apply(
                        lambda v: format_percent(v, decimals=percent_decimals) if v is not None else "—"
                    )
                    st.dataframe(sc_display, width='stretch')

            three_year_summary = next(
                (row for row in scenario_summary if row.get("period_label") == "3 years"),
                None,
            )
            if three_year_summary:
                projected_profit = three_year_summary.get("projected_total_eur")
                projected_revenue = three_year_summary.get("projected_revenue_eur")
                projected_cost = three_year_summary.get("projected_cost_eur")
                projected_loss = three_year_summary.get("projected_loss_eur")
                projected_spread = three_year_summary.get("projected_spread_eur_mwh")

                if any(
                    value is not None
                    for value in (
                        projected_profit,
                        projected_revenue,
                        projected_cost,
                        projected_loss,
                        projected_spread,
                    )
                ):
                    st.subheader("Simulated 3-Year Totals (scenario)")
                    sim_cols = st.columns(5)
                    sim_cols[0].metric(
                        "Profit (3y sim)",
                        format_currency(
                            projected_profit or three_year_summary.get("recent_total_eur", 0.0),
                            decimals=currency_decimals,
                            thousands=thousands_sep,
                        ),
                    )
                    sim_cols[1].metric(
                        "Revenue (3y sim)",
                        format_currency(
                            projected_revenue or three_year_summary.get("recent_revenue_eur", 0.0),
                            decimals=currency_decimals,
                            thousands=thousands_sep,
                        ),
                    )
                    sim_cols[2].metric(
                        "Cost (3y sim)",
                        format_currency(
                            projected_cost or three_year_summary.get("recent_cost_eur", 0.0),
                            decimals=currency_decimals,
                            thousands=thousands_sep,
                        ),
                    )
                    sim_cols[3].metric(
                        "Loss (3y sim)",
                        format_currency(
                            projected_loss or three_year_summary.get("recent_loss_eur", 0.0),
                            decimals=currency_decimals,
                            thousands=thousands_sep,
                        ),
                    )
                    sim_cols[4].metric(
                        "Spread €/MWh (3y sim)",
                        format_price_per_mwh(
                            projected_spread
                            or three_year_summary.get("recent_spread_eur_mwh"),
                            decimals=max(currency_decimals, 2),
                        ),
                    )

                    # Chart projections based on proportional scaling of the selected window
                    scenario_days = max(int(three_year_summary.get("recent_days", 0)), 1)
                    expected_days = max(int(three_year_summary.get("expected_days", scenario_days)), scenario_days)
                    scaling_factor = expected_days / scenario_days if scenario_days else 1.0

                    recent_history = three_year_summary.get("recent_total_eur", 0.0)
                    projected_history = projected_profit or recent_history * scaling_factor

                    comparison_table = pd.DataFrame(
                        {
                            "Phase": ["Actual window", "Projected 3y"],
                            "Profit €": [
                                format_currency(recent_history, decimals=currency_decimals, thousands=thousands_sep),
                                format_currency(projected_history, decimals=currency_decimals, thousands=thousands_sep),
                            ],
                        }
                    )
                    st.table(comparison_table)

            cash_flow_scenario = build_cash_flow_summary(scenario_history, freq="M")
            if not cash_flow_scenario.empty:
                st.subheader("36-Month Cash Flow (scenario)")
                scen_display = cash_flow_scenario.copy()
                period_col = "Month" if "Month" in scen_display.columns else "Year"
                preferred_cols = [
                    period_col,
                    "Days",
                    "Turnover €",
                    "Cost €",
                    "Profit €",
                    "Loss €",
                    "Avg buy €/MWh",
                    "Avg sell €/MWh",
                    "Spread €/MWh",
                ]
                remaining_cols = [c for c in scen_display.columns if c not in preferred_cols]
                scen_display = scen_display[[c for c in preferred_cols if c in scen_display.columns] + remaining_cols]
                scen_currency_cols = ["Turnover €", "Cost €", "Profit €", "Loss €"]
                for col in scen_currency_cols:
                    if col in scen_display.columns:
                        scen_display[col] = scen_display[col].apply(
                            lambda v, d=currency_decimals: format_currency(
                                v, decimals=d, thousands=thousands_sep
                            )
                            if v is not None
                            else "—"
                        )
                scen_price_cols = ["Avg buy €/MWh", "Avg sell €/MWh", "Spread €/MWh"]
                scen_price_decimals = max(currency_decimals, 2)
                for col in scen_price_cols:
                    if col in scen_display.columns:
                        scen_display[col] = scen_display[col].apply(
                            lambda v, d=scen_price_decimals: format_price_per_mwh(v, decimals=d)
                            if v is not None
                            else "—"
                        )
                st.dataframe(scen_display, width='stretch')

        # Year-by-year best fixed hours summary (PZU only)
        best_years_df = compute_best_hours_by_year(
            provider.pzu_csv,
            round_trip_efficiency=eta_rt,
            capacity_mwh=capacity_mwh,
            power_mw=power_mw,
            years=[2022, 2023, 2024, 2025],
        )

        if not best_years_df.empty:
            st.subheader("📊 Best Buy/Sell Hours Per Year (PZU)")
            st.caption(
                "Optimal 2-hour charge/discharge schedule computed separately for each calendar year,"
                " with annual profit at those hours."
            )

            display_years = []
            for _, row in best_years_df.iterrows():
                buy = int(row["buy_hour"])
                sell = int(row["sell_hour"])
                buy_end = min(buy + 2, 24)
                sell_end = min(sell + 2, 24)
                display_years.append(
                    {
                        "Year": str(int(row["year"])),
                        "Charge window": f"{buy:02d}:00–{buy_end:02d}:00",
                        "Discharge window": f"{sell:02d}:00–{sell_end:02d}:00",
                        "Profit €": format_currency(row.get("profit_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
                        "Revenue €": format_currency(row.get("revenue_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
                        "Cost €": format_currency(row.get("cost_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
                        "Avg buy €/MWh": format_price_per_mwh(row.get("avg_buy_price_eur_mwh"), decimals=max(currency_decimals, 2)),
                        "Avg sell €/MWh": format_price_per_mwh(row.get("avg_sell_price_eur_mwh"), decimals=max(currency_decimals, 2)),
                        "Spread €/MWh": format_price_per_mwh(row.get("spread_eur_mwh"), decimals=max(currency_decimals, 2)),
                    }
                )

            year_df = pd.DataFrame(display_years)
            preferred_order = [
                "Year",
                "Charge window",
                "Discharge window",
                "Profit €",
                "Revenue €",
                "Cost €",
                "Avg buy €/MWh",
                "Avg sell €/MWh",
                "Spread €/MWh",
            ]
            year_df = year_df[[col for col in preferred_order if col in year_df.columns]]
            st.dataframe(year_df, width='stretch')

    if view == "ROI & Trends":
        if daily_history.empty:
            st.info("No historical PZU data available.")
        else:
            st.subheader("📅 Monthly Profitability Trends")
            monthly_trends = analyze_historical_monthly_trends_only(provider.pzu_csv, capacity_mwh, eta_rt, start_year=2023)
            if 'error' in monthly_trends:
                st.error(monthly_trends['error'])
                if 'suggestion' in monthly_trends:
                    st.info(monthly_trends['suggestion'])
            elif 'info' in monthly_trends:
                st.info(monthly_trends['info'])
                if 'reason' in monthly_trends:
                    st.caption(monthly_trends['reason'])
                if 'suggestion' in monthly_trends:
                    st.caption(f"💡 {monthly_trends['suggestion']}")
            else:
                st.success(f"✅ {monthly_trends['analysis_type']} - {monthly_trends['total_months']} months analyzed")
                if 'monthly_data' in monthly_trends and len(monthly_trends['monthly_data']) > 0:
                    monthly_data = monthly_trends['monthly_data']
                    months = [m['month'] for m in monthly_data]
                    profits = [m['total_monthly_profit'] for m in monthly_data]
                    with safe_pyplot_figure(figsize=(12, 6)) as (fig_monthly, ax_monthly):
                        chart_colors = get_chart_colors()
                        ax_monthly.bar(range(len(months)), profits, alpha=0.7, color=chart_colors['darkgreen'])
                        ax_monthly.set_xlabel('Month'); ax_monthly.set_ylabel('Monthly Profit (EUR)')
                        ax_monthly.set_title(f"Historical Monthly Profitability ({monthly_trends.get('data_period', 'historical range')})")
                        ax_monthly.set_xticks(range(len(months))); ax_monthly.set_xticklabels(months, rotation=45)
                        ax_monthly.grid(True, alpha=0.3); ax_monthly.axhline(y=0, color=chart_colors['red'], linestyle='-', alpha=0.5)
                        plt.tight_layout()
                        st.pyplot(fig_monthly, clear_figure=True)

            st.subheader("💡 Historical ROI (from 2023)")
            roi_window = st.radio("ROI window (months)", options=[12, 24], index=0, horizontal=True)
            roi12 = calculate_historical_roi_metrics(provider.pzu_csv, capacity_mwh, investment_eur=6_500_000, start_year=2023, window_months=12, round_trip_efficiency=eta_rt)
            roi24 = calculate_historical_roi_metrics(provider.pzu_csv, capacity_mwh, investment_eur=6_500_000, start_year=2023, window_months=24, round_trip_efficiency=eta_rt)
            chosen_roi = roi12 if roi_window == 12 else roi24
            if 'error' in chosen_roi:
                st.error(chosen_roi['error'])
            elif 'info' in chosen_roi:
                st.info(chosen_roi['info'])
                if 'reason' in chosen_roi:
                    st.caption(chosen_roi['reason'])
                if 'suggestion' in chosen_roi:
                    st.caption(f"💡 {chosen_roi['suggestion']}")
            else:
                r1, r2, r3, r4 = st.columns(4)
                r1.metric("🎯 Annual ROI", format_percent(chosen_roi['roi_annual_percent'], decimals=percent_decimals))
                r2.metric("💰 Annualized Profit", format_currency(chosen_roi['annualized_profit_eur'], decimals=currency_decimals, thousands=thousands_sep))
                r3.metric("⏳ Payback Period", f"{chosen_roi['payback_years']:.1f} years" if chosen_roi['payback_years'] != float('inf') else "∞")
                r4.metric("🏁 Window", f"{chosen_roi['window_months']} mo")
                st.caption(f"Investment assumed: €{chosen_roi['investment_eur']:,.0f} | Data period: {chosen_roi.get('data_period','N/A')}")

            st.subheader("⏱️ 3‑Year Best‑Hour Arbitrage Estimate (OPCOM PZU)")
            best3 = analyze_pzu_best_hours_min_years(provider.pzu_csv, min_years=3, round_trip_efficiency=eta_rt, capacity_mwh=capacity_mwh, investment_eur=6_500_000)
            if 'error' in best3:
                st.warning(best3['error'])
                if 'suggestion' in best3:
                    st.caption(best3['suggestion'])
            else:
                b1, b2, b3, b4, b5 = st.columns(5)
                b1.metric("Best BUY hour", f"{best3['buy_hour']:02d}:00", help="Hour-of-day with lowest 3-year average price")
                b2.metric("Best SELL hour", f"{best3['sell_hour']:02d}:00", help="Hour-of-day with highest 3-year average price")
                b3.metric("Net spread", format_currency(best3['net_spread_eur_mwh'], decimals=2) + "/MWh")
                b4.metric("Daily profit", format_currency(best3['daily_profit_eur'], decimals=0))
                b5.metric("Annual profit", format_currency(best3['annual_profit_eur'], decimals=0))
                rb1, rb2 = st.columns(2)
                rb1.metric("Annual ROI", format_percent(best3['roi_annual_percent'], decimals=1))
                rb2.metric("Payback", f"{best3['payback_years']:.1f} years" if best3['payback_years'] != float('inf') else "∞")
                st.caption(f"Period: {best3['data_period']} ({best3['period_months']} months)")

            st.subheader("🕒 Multi‑hour Buffer Strategy (3y averages)")
            colb1, colb2, colb3 = st.columns(3)
            with colb1:
                buf_buy = st.slider("Buy hours (per cycle)", 1, 6, 2)
            with colb2:
                buf_sell = st.slider("Sell hours (per cycle)", 1, 6, 2)
            with colb3:
                cycles_day = st.slider("Cycles per day", 1, 3, int(cfg.get('strategy', {}).get('pzu', {}).get('daily_cycles_target', 1)))

            mh = plan_multi_hour_strategy_from_history(
                provider.pzu_csv,
                min_years=3,
                round_trip_efficiency=eta_rt,
                capacity_mwh=capacity_mwh,
                power_mw=power_mw,
                buy_hours_buffer=int(buf_buy),
                sell_hours_buffer=int(buf_sell),
                cycles_per_day=int(cycles_day),
                investment_eur=6_500_000,
            )
            if isinstance(mh, tuple) and 'error' in mh[0]:
                st.warning(mh[0]['error'])
            elif 'error' in mh:
                st.warning(mh['error'])
            else:
                mcol1, mcol2, mcol3, mcol4 = st.columns(4)
                mcol1.metric("Profit/cycle", format_currency(mh['profit_per_cycle_eur'], decimals=0))
                mcol2.metric("Cycles/day used", f"{mh['cycles_used_per_day']}")
                mcol3.metric("Daily profit", format_currency(mh['daily_profit_eur'], decimals=0))
                mcol4.metric("Annual profit", format_currency(mh['annual_profit_eur'], decimals=0))
                mcol5, mcol6 = st.columns(2)
                mcol5.metric("Annual ROI", format_percent(mh['roi_annual_percent'], decimals=1))
                mcol6.metric("Payback", f"{mh['payback_years']:.1f} years" if mh['payback_years'] != float('inf') else "∞")
                st.caption(f"Buy hours: {sorted(mh['buy_hours'])} | Sell hours: {sorted(mh['sell_hours'])}")

    if view == "Romanian BM":
        st.subheader("🇷🇴 Romanian Balancing Market Analysis")
        if bm_series is None or len(bm_series) == 0:
            st.info("No balancing market data for the selected date.")
        else:
            # Romanian balancing market analysis
            romanian_bm_analysis = analyze_romanian_balancing_market(bm_series, capacity_mwh)
            
            if 'error' in romanian_bm_analysis:
                st.error(romanian_bm_analysis['error'])
            else:
                # Market Overview
                st.success(f"📊 {romanian_bm_analysis['market_name']}")
                st.caption(f"Operator: {romanian_bm_analysis['operator']} | Platform: {romanian_bm_analysis['trading_platform']}")
                
                # Key Market Characteristics
                st.subheader("⚡ Market Characteristics")
                char_col1, char_col2 = st.columns(2)
                char_col1.metric("Time Resolution", romanian_bm_analysis['time_resolution'])
                char_col2.metric("Market Type", romanian_bm_analysis['market_type'])
                char_col1.metric("Data Points", romanian_bm_analysis['data_points'])
                min_bid = romanian_bm_analysis.get('minimum_bid_size_mw')
                char_col2.metric("Min Bid Size", f"{min_bid} MW" if min_bid is not None else "N/A")
                
                # Price Analysis
                st.subheader("💰 Price Analysis")
                price_col1, price_col2, price_col3 = st.columns(3)
                price_col1.metric("Avg Price (EUR)", f"€{romanian_bm_analysis['avg_imbalance_price_eur_mwh']:.2f}/MWh")
                price_col2.metric("Price Range (EUR)", f"€{romanian_bm_analysis['price_range_eur_mwh']:.2f}/MWh")
                price_col3.metric("Volatility", f"{romanian_bm_analysis['price_volatility']:.2f}")
                
                # System Balance Analysis
                if 'system_imbalance_analysis' in romanian_bm_analysis:
                    st.subheader("⚖️ System Balance Analysis")
                    balance = romanian_bm_analysis['system_imbalance_analysis']
                    bal_col1, bal_col2, bal_col3 = st.columns(3)
                    bal_col1.metric("System Deficit", f"{balance['deficit_percentage']:.1f}%", help="Periods with positive prices")
                    bal_col2.metric("System Surplus", f"{balance['surplus_percentage']:.1f}%", help="Periods with negative prices")
                    bal_col3.metric("Balanced System", f"{balance['balanced_percentage']:.1f}%", help="Periods with zero prices")
                    
                    # Dominant condition indicator
                    if balance['dominant_imbalance'] == 'Generation Deficit':
                        st.warning(f"⚠️ System predominantly in **{balance['dominant_imbalance']}** (excess demand)")
                    else:
                        st.info(f"ℹ️ System predominantly in **{balance['dominant_imbalance']}** (excess generation)")
                
                # Frequency Regulation Services
                st.subheader("🔧 Frequency Regulation Services")
                response_times = romanian_bm_analysis['minimum_response_time_seconds']
                resp_col1, resp_col2, resp_col3 = st.columns(3)
                resp_col1.metric("FCR Response", f"{response_times}s", help="Frequency Containment Reserve")
                resp_col2.metric("aFRR Response", f"{response_times * 10}s", help="Automatic Frequency Restoration")
                resp_col3.metric("mFRR Response", f"{response_times * 30}s", help="Manual Frequency Restoration")
                
                # Revenue Model
                st.subheader("💼 Revenue Model for BESS")
                if romanian_bm_analysis['arbitrage_trading']:
                    st.success("✅ Suitable for arbitrage trading")
                else:
                    st.info("❌ Not suitable for arbitrage trading")
                
                if romanian_bm_analysis['frequency_regulation_services']:
                    st.success("✅ Suitable for frequency regulation services")
                    st.caption("Revenue streams: Availability payments + Activation payments")
                else:
                    st.warning("❌ Not suitable for frequency regulation")
                
                # Regulatory Framework
                st.subheader("📋 Regulatory Framework")
                reg_framework = romanian_bm_analysis['regulatory_framework']
                st.write(f"**Grid Operator:** {reg_framework['grid_operator']}")
                st.write(f"**Market Regulator:** {reg_framework['market_regulator']}")
                st.write(f"**EU Compliance:** {reg_framework['european_compliance']}")
                st.write(f"**Grid Code:** {reg_framework['grid_code']}")
                
                # Key Differences
                st.subheader("🔑 Key Differences from OPCOM")
                for difference in romanian_bm_analysis['key_differences_from_opcom']:
                    st.write(f"• {difference}")
                
                # BESS Participation Requirements
                st.subheader("📜 BESS Participation Requirements")
                for requirement in romanian_bm_analysis['bess_participation_requirements']:
                    st.write(f"• {requirement}")
                
                # Price chart (robust to empty/NaN; avoid Vega-Lite warnings by using Matplotlib)
                st.subheader("📈 Imbalance Prices")
                bm_df = pd.DataFrame({"slot": list(range(len(bm_series))), "price_ron_mwh": bm_series})
                bm_df = bm_df.replace([np.inf, -np.inf], np.nan).dropna()
                if bm_df.empty:
                    st.info("No balancing price points to plot for the selected date.")
                else:
                    with safe_pyplot_figure(figsize=(10, 3)) as (fig_bm, ax_bm):
                        chart_colors = get_chart_colors()
                        ax_bm.plot(bm_df["slot"], bm_df["price_ron_mwh"], color=chart_colors['primary'])
                        ax_bm.set_xlabel("Slot (15-min)")
                        ax_bm.set_ylabel("Price (RON/MWh)")
                        ax_bm.grid(True, alpha=0.3)
                        st.pyplot(fig_bm, clear_figure=True)
                
                # Traditional stats
                st.subheader("📊 Statistical Summary")
                st.json(bm_stats(bm_series))

        

if view == "FR Simulator":
    render_frequency_regulation_simulator(cfg)

if view == "Market Comparison":
    st.subheader("🔄 Market Comparison (latest runs)")
    render_historical_market_comparison(cfg, capacity_mwh, eta_rt)

if view == "FR Energy Hedging":
    st.subheader("⚖️ FR Energy Hedging Workbook")
    st.caption(
        "Reuse the latest FR Simulator run and our stored PZU data to estimate the cost of hedging"
        " activation energy on OPCOM while earning FR revenue on Transelectrica."
    )

    fr_metrics = st.session_state.get("fr_market_metrics")
    if not isinstance(fr_metrics, dict) or not fr_metrics.get("months"):
        st.info("Run the FR Simulator first to populate activation data.")
    else:
        fr_months_df = pd.DataFrame(fr_metrics["months"])
        if fr_months_df.empty or "month" not in fr_months_df.columns:
            st.info("No monthly activation data available; run the FR Simulator again.")
        else:
            try:
                fr_months_df["month_period"] = pd.PeriodIndex(fr_months_df["month"], freq="M")
            except Exception:
                fr_months_df["month_period"] = pd.to_datetime(fr_months_df["month"], errors="coerce").dt.to_period("M")
            fr_months_df = fr_months_df.dropna(subset=["month_period"]).sort_values("month_period")
            fr_months_df["month"] = fr_months_df["month_period"].astype(str)

            for col in ["energy_cost_eur", "activation_revenue_eur", "activation_energy_mwh"]:
                if col in fr_months_df.columns:
                    fr_months_df[col] = pd.to_numeric(fr_months_df[col], errors="coerce")

            cost_mask = fr_months_df.get("energy_cost_eur", pd.Series(dtype=float)).fillna(0.0) > 0.0
            if cost_mask.any():
                avg_cost = fr_months_df.loc[cost_mask, "energy_cost_eur"].mean()
                fr_months_df.loc[~cost_mask, "energy_cost_eur"] = avg_cost

            act_mask = fr_months_df.get("activation_revenue_eur", pd.Series(dtype=float)).fillna(0.0) > 0.0
            if act_mask.any():
                avg_act = fr_months_df.loc[act_mask, "activation_revenue_eur"].mean()
                fr_months_df.loc[~act_mask, "activation_revenue_eur"] = avg_act

            energy_mask = fr_months_df.get("activation_energy_mwh", pd.Series(dtype=float)).fillna(0.0) > 0.0
            if energy_mask.any():
                avg_energy = fr_months_df.loc[energy_mask, "activation_energy_mwh"].mean()
                fr_months_df.loc[~energy_mask, "activation_energy_mwh"] = avg_energy

            if {"capacity_revenue_eur", "activation_revenue_eur"}.issubset(fr_months_df.columns):
                fr_months_df["total_revenue_eur"] = (
                    fr_months_df["capacity_revenue_eur"].fillna(0.0)
                    + fr_months_df["activation_revenue_eur"].fillna(0.0)
                )

            hedging_window = st.slider(
                "Hedging window (months)",
                min_value=1,
                max_value=len(fr_months_df),
                value=min(12, len(fr_months_df)),
                step=1,
            )

            fr_window = fr_months_df.tail(hedging_window).reset_index(drop=True)
            activation_mwh = float(fr_window.get("activation_energy_mwh", 0.0).sum())
            activation_revenue = float(fr_window.get("total_revenue_eur", 0.0).sum())
            activation_cost = float(fr_window.get("energy_cost_eur", 0.0).sum())

            pzu_start = fr_window["month_period"].min().to_timestamp() if not fr_window.empty else None
            pzu_end = fr_window["month_period"].max().to_timestamp() if not fr_window.empty else None

            pzu_monthly = compute_pzu_monthly_costs(
                provider.pzu_csv,
                start_date=pzu_start,
                end_date=pzu_end,
            )

            if pzu_monthly.empty:
                st.warning("No OPCOM PZU data available for the same window.")
                reference_price = 0.0
            else:
                st.subheader("OPCOM PZU Monthly Prices")
                pzu_display = pzu_monthly.rename(
                    columns={
                        "month": "Month",
                        "avg_price_eur_mwh": "Avg €/MWh",
                        "min_price_eur_mwh": "Min €/MWh",
                        "max_price_eur_mwh": "Max €/MWh",
                    }
                )
                for col in ["Avg €/MWh", "Min €/MWh", "Max €/MWh"]:
                    pzu_display[col] = pzu_display[col].apply(
                        lambda v: format_price_per_mwh(v, decimals=max(currency_decimals, 2))
                    )
                st.dataframe(pzu_display, width='stretch')

                reference_price = float(
                    pzu_monthly["avg_price_eur_mwh"].astype(float).mean()
                    if not pzu_monthly.empty
                    else 0.0
                )

            st.subheader("FR vs OPCOM Hedging Summary")
            summary_cols = st.columns(4)
            summary_cols[0].metric(
                "Activation energy (MWh)", f"{activation_mwh:.2f}", help="Energy delivered or absorbed in FR activations."
            )
            summary_cols[1].metric(
                "FR revenue (window)",
                format_currency(activation_revenue, decimals=currency_decimals, thousands=thousands_sep),
            )

            hedging_cost = activation_mwh * reference_price if reference_price else 0.0
            summary_cols[2].metric(
                "PZU hedging cost",
                format_currency(hedging_cost, decimals=currency_decimals, thousands=thousands_sep),
                help="Energy cost = activation MWh × average OPCOM price over the same months.",
            )

            summary_cols[3].metric(
                "Net margin",
                format_currency(activation_revenue - hedging_cost, decimals=currency_decimals, thousands=thousands_sep),
            )

            st.subheader("Detailed Hedging Breakdown")
            hedging_rows = []
            for _, row in fr_window.iterrows():
                month_label = str(row.get("month"))
                energy_mwh = float(row.get("activation_energy_mwh", 0.0))
                pzu_row = pzu_monthly[pzu_monthly["month"] == month_label]
                pzu_price = float(pzu_row["avg_price_eur_mwh"].iloc[0]) if not pzu_row.empty else reference_price
                row_cost = energy_mwh * pzu_price
                hedging_rows.append(
                    {
                        "Month": month_label,
                        "Activation MWh": f"{energy_mwh:.2f}",
                        "Hedge price €/MWh": format_price_per_mwh(pzu_price, decimals=max(currency_decimals, 2)),
                        "Hedging cost €": format_currency(row_cost, decimals=currency_decimals, thousands=thousands_sep),
                        "FR revenue €": format_currency(float(row.get("total_revenue_eur", 0.0)), decimals=currency_decimals, thousands=thousands_sep),
                        "FR energy cost €": format_currency(float(row.get("energy_cost_eur", 0.0)), decimals=currency_decimals, thousands=thousands_sep),
                    }
                )

            if hedging_rows:
                hedging_df = pd.DataFrame(hedging_rows)
                st.dataframe(hedging_df, width='stretch')
            else:
                st.info("No FR activation rows available for the selected window.")

    # ---- Annual best-hours table (always shown at page end) ----
    best_years_df = compute_best_hours_by_year(
        provider.pzu_csv,
        round_trip_efficiency=eta_rt,
        capacity_mwh=capacity_mwh,
        power_mw=power_mw,
        years=[2022, 2023, 2024, 2025],
    )

    if not best_years_df.empty:
        st.subheader("📊 Best Buy/Sell Hours Per Year (PZU)")
        st.caption(
            "Optimal 2-hour charge/discharge schedule computed separately for each calendar year,"
            " with annual profit at those hours."
        )

        display_years = []
        for _, row in best_years_df.iterrows():
            buy = int(row["buy_hour"])
            sell = int(row["sell_hour"])
            buy_end = min(buy + 2, 24)
            sell_end = min(sell + 2, 24)
            display_years.append(
                {
                    "Year": str(int(row["year"])),
                    "Charge window": f"{buy:02d}:00–{buy_end:02d}:00",
                    "Discharge window": f"{sell:02d}:00–{sell_end:02d}:00",
                    "Profit €": format_currency(row.get("profit_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
                    "Revenue €": format_currency(row.get("revenue_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
                    "Cost €": format_currency(row.get("cost_eur", 0.0), decimals=currency_decimals, thousands=thousands_sep),
                    "Avg buy €/MWh": format_price_per_mwh(row.get("avg_buy_price_eur_mwh"), decimals=max(currency_decimals, 2)),
                    "Avg sell €/MWh": format_price_per_mwh(row.get("avg_sell_price_eur_mwh"), decimals=max(currency_decimals, 2)),
                    "Spread €/MWh": format_price_per_mwh(row.get("spread_eur_mwh"), decimals=max(currency_decimals, 2)),
                }
            )

        year_df = pd.DataFrame(display_years)
        preferred_order = [
            "Year",
            "Charge window",
            "Discharge window",
            "Profit €",
            "Revenue €",
            "Cost €",
            "Avg buy €/MWh",
            "Avg sell €/MWh",
            "Spread €/MWh",
        ]
        year_df = year_df[[col for col in preferred_order if col in year_df.columns]]
        st.dataframe(year_df, width='stretch')

if view == "Investment & Financing":
    render_investment_financing_analysis(cfg)

__all__ = [
    "simulate_frequency_regulation_revenue",
    "apply_soc_constraints_to_activation",
    "simulate_frequency_regulation_revenue_multi",
]
