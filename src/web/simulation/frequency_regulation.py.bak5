from __future__ import annotations

from typing import Dict, List, Optional, Tuple
from pathlib import Path
from datetime import date, datetime

import numpy as np
import pandas as pd
import streamlit as st

from src.web.config import project_root
from src.web.data import load_config
from src.data.data_provider import DataProvider
from src.web.utils import safe_pyplot_figure


@st.cache_data(show_spinner=False)
def simulate_frequency_regulation_revenue(
    prices_eur: pd.DataFrame,
    contracted_mw: float,
    capacity_price_eur_mw_h: float,
    up_threshold_eur_mwh: float = 0.0,
    down_threshold_eur_mwh: float = 0.0,
    pay_down_as_positive: bool = True,
) -> Dict:
    """Estimate revenue using estimated imbalance prices as proxy for activation price.
    - Capacity revenue = contracted_mw * hours_available_in_month * capacity_price_eur_mw_h
      where hours_available_in_month is computed from the presence of any price entries that month.
    - Activation revenue: when price >= up_threshold or price <= -down_threshold, assume full contracted MW activated.
    - Energy per 15-min slot = contracted_mw * 0.25 MWh.
    - If pay_down_as_positive=True, down-activation uses |price|; else uses signed price.
    """
    if prices_eur is None or prices_eur.empty or contracted_mw <= 0:
        return {
            'monthly': [],
            'totals': {
                'capacity_revenue_eur': 0.0,
                'activation_revenue_eur': 0.0,
                'total_revenue_eur': 0.0,
                'months': 0
            }
        }

    df = prices_eur.copy()
    df['date'] = pd.to_datetime(df['date'])
    df['month'] = df['date'].dt.to_period('M')

    monthly_rows = []
    cap_total = 0.0
    act_total = 0.0

    for month, mdf in df.groupby('month'):
        hours_in_data = len(mdf) * 0.25
        cap_rev = contracted_mw * hours_in_data * capacity_price_eur_mw_h
        # Activation flags
        up_mask = mdf['price_eur_mwh'] >= float(up_threshold_eur_mwh)
        down_mask = mdf['price_eur_mwh'] <= -float(down_threshold_eur_mwh)
        # Energy per slot
        energy_mwh_per_slot = contracted_mw * 0.25
        # Up activation revenue
        up_rev = float((mdf.loc[up_mask, 'price_eur_mwh'] * energy_mwh_per_slot).sum())
        # Down activation revenue (toggle absolute or signed)
        if pay_down_as_positive:
            down_rev = float((mdf.loc[down_mask, 'price_eur_mwh'].abs() * energy_mwh_per_slot).sum())
        else:
            down_rev = float((mdf.loc[down_mask, 'price_eur_mwh'] * energy_mwh_per_slot).sum())
        act_rev = up_rev + down_rev

        monthly_rows.append({
            'month': str(month),
            'hours_in_data': hours_in_data,
            'capacity_revenue_eur': cap_rev,
            'activation_revenue_eur': act_rev,
            'total_revenue_eur': cap_rev + act_rev,
            'up_slots': int(up_mask.sum()),
            'down_slots': int(down_mask.sum()),
        })
        cap_total += cap_rev
        act_total += act_rev

    monthly_rows.sort(key=lambda x: x['month'])

    return {
        'monthly': monthly_rows,
        'totals': {
            'capacity_revenue_eur': cap_total,
            'activation_revenue_eur': act_total,
            'total_revenue_eur': cap_total + act_total,
            'months': len(monthly_rows)
        }
    }




def apply_soc_constraints_to_activation(
    df: pd.DataFrame,
    up_mask: pd.Series,
    down_mask: pd.Series,
    energy_per_slot_mwh: pd.Series,
    battery_capacity_mwh: float,
    initial_soc: float = 0.5,
    soc_min: float = 0.1,
    soc_max: float = 0.9,
    round_trip_efficiency: float = 0.9,
) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """Apply battery SOC constraints to FR activation events.

    Parameters
    ----------
    df : pd.DataFrame
        Dataframe with date/slot columns (must be sorted chronologically)
    up_mask : pd.Series
        Boolean mask indicating up-regulation activation (discharge)
    down_mask : pd.Series
        Boolean mask indicating down-regulation activation (charge)
    energy_per_slot_mwh : pd.Series
        Planned energy per 15-min slot before SOC constraints
    battery_capacity_mwh : float
        Battery energy capacity (MWh)
    initial_soc : float, optional
        Starting SOC fraction (0-1), default 0.5 (50%)
    soc_min : float, optional
        Minimum allowed SOC fraction (0-1), default 0.1 (10%)
    soc_max : float, optional
        Maximum allowed SOC fraction (0-1), default 0.9 (90%)
    round_trip_efficiency : float, optional
        Round-trip efficiency (0-1), default 0.9

    Returns
    -------
    constrained_up_energy : pd.Series
        Actual up-regulation energy after SOC constraints (MWh)
    constrained_down_energy : pd.Series
        Actual down-regulation energy after SOC constraints (MWh)
    soc_series : pd.Series
        SOC evolution over time (0-1 fraction)

    Notes
    -----
    Romania's ANRE regulations require batteries to maintain operational SOC ranges
    to ensure continued FR availability. This function simulates realistic physical
    constraints:
    - Cannot discharge below SOC_min (typically 10-20%)
    - Cannot charge above SOC_max (typically 80-90%)
    - Efficiency losses occur during charge/discharge cycles
    - SOC must be managed to maintain bi-directional capability

    When SOC constraints are violated, activation energy is reduced or blocked,
    which directly impacts revenue and demonstrates why SOC management is critical
    for FR participation.
    """
    n = len(df)
    soc = np.full(n, initial_soc, dtype=float)
    actual_up_energy = np.zeros(n, dtype=float)
    actual_down_energy = np.zeros(n, dtype=float)

    charge_efficiency = np.sqrt(round_trip_efficiency)  # √η for charge
    discharge_efficiency = np.sqrt(round_trip_efficiency)  # √η for discharge

    for i in range(n):
        # Start with previous SOC
        if i > 0:
            soc[i] = soc[i - 1]

        current_soc = soc[i]
        available_energy_mwh = current_soc * battery_capacity_mwh
        available_headroom_mwh = (soc_max - current_soc) * battery_capacity_mwh

        # Up-regulation (discharge): limited by available energy above SOC_min
        if up_mask.iloc[i]:
            max_discharge = max(0.0, (current_soc - soc_min) * battery_capacity_mwh)
            requested_discharge = energy_per_slot_mwh.iloc[i]
            actual_discharge = min(requested_discharge, max_discharge)

            actual_up_energy[i] = actual_discharge
            # Update SOC: discharge reduces SOC
            energy_from_battery = actual_discharge / discharge_efficiency  # Account for discharge inefficiency
            soc[i] = max(soc_min, current_soc - (energy_from_battery / battery_capacity_mwh))

        # Down-regulation (charge): limited by available headroom below SOC_max
        elif down_mask.iloc[i]:
            max_charge = max(0.0, available_headroom_mwh)
            requested_charge = energy_per_slot_mwh.iloc[i]
            actual_charge = min(requested_charge, max_charge)

            actual_down_energy[i] = actual_charge
            # Update SOC: charge increases SOC (with losses)
            energy_to_battery = actual_charge * charge_efficiency  # Account for charge inefficiency
            soc[i] = min(soc_max, current_soc + (energy_to_battery / battery_capacity_mwh))

    return (
        pd.Series(actual_up_energy, index=df.index),
        pd.Series(actual_down_energy, index=df.index),
        pd.Series(soc, index=df.index),
    )



@st.cache_data(show_spinner=False)
def simulate_frequency_regulation_revenue_multi(
    prices_eur: pd.DataFrame,
    products: Dict[str, Dict[str, float]],
    pay_down_as_positive: bool = True,
    pay_down_positive_map: Optional[Dict[str, bool]] = None,
    activation_factor_map: Optional[Dict[str, float]] = None,
    calendars: Optional[Dict[str, pd.DataFrame]] = None,
    system_imbalance_df: Optional[pd.DataFrame] = None,
    activation_curve_map: Optional[Dict[str, pd.Series]] = None,
    activation_price_mode: str = "market",
    pay_as_bid_map: Optional[Dict[str, Dict[str, float]]] = None,
    battery_power_mw: Optional[float] = None,
    battery_capacity_mwh: Optional[float] = None,
    initial_soc: float = 0.5,
    soc_min: float = 0.1,
    soc_max: float = 0.9,
    round_trip_efficiency: float = 0.9,
    enable_soc_tracking: bool = True,
    merit_order_activation_rate: float = 0.5,
) -> Dict:
    """Multi-product simulation for FCR/aFRR/mFRR with SOC tracking and merit-order logic.

    Parameters
    ----------
    battery_capacity_mwh : float, optional
        Battery energy capacity in MWh. Required if enable_soc_tracking=True.
    initial_soc : float, default 0.5
        Initial State of Charge as fraction (0-1)
    soc_min : float, default 0.1
        Minimum allowed SOC (0-1)
    soc_max : float, default 0.9
        Maximum allowed SOC (0-1)
    round_trip_efficiency : float, default 0.9
        Battery round-trip efficiency (0-1)
    enable_soc_tracking : bool, default True
        Enable realistic SOC constraints on activation energy
    merit_order_activation_rate : float, default 0.5
        Conservative activation rate (0-1) to model merit-order dispatch.
        Represents average probability of activation based on bid position.
        0.3 = aggressive low bids (30% avg activation)
        0.5 = mid-stack bids (50% avg activation)
        0.7 = conservative high bids (70% avg activation)

    Products format example:
    {
      'FCR': {'enabled': True, 'mw': 10, 'cap_eur_mw_h': 7.5, 'up_thr': 0.0, 'down_thr': 0.0},
      'aFRR': {'enabled': True, 'mw': 15, 'cap_eur_mw_h': 5.0, 'up_thr': 0.0, 'down_thr': 0.0},
      'mFRR': {'enabled': False, 'mw': 0,  'cap_eur_mw_h': 0.0, 'up_thr': 0.0, 'down_thr': 0.0},
    }

    Notes
    -----
    Romania Pay-as-Bid Regime (ANRE 2024):
    - From July 2024 until December 31, 2026, balancing market uses pay-as-bid pricing
    - Each provider receives their bid price, not the marginal market price
    - Set activation_price_mode="pay_as_bid" and provide pay_as_bid_map
    - After 2026, market may revert to marginal pricing (update activation_price_mode accordingly)
    """
    if prices_eur is None or prices_eur.empty:
        return {'monthly_by_product': {}, 'totals_by_product': {}, 'combined_monthly': [], 'combined_totals': {'capacity_revenue_eur': 0.0, 'activation_revenue_eur': 0.0, 'total_revenue_eur': 0.0, 'months': 0}}

    df = prices_eur.copy()
    df['date'] = pd.to_datetime(df['date'])
    df['month'] = df['date'].dt.to_period('M')

    has_imbalance = (system_imbalance_df is not None) and (not system_imbalance_df.empty)

    monthly_by_product: Dict[str, List[Dict]] = {}
    totals_by_product: Dict[str, Dict[str, float]] = {}

    # For combined monthly, accumulate by month label
    combined_month_map: Dict[str, Dict[str, float]] = {}

    for prod, cfg in products.items():
        if not cfg.get('enabled'):
            continue
        mw = float(cfg.get('mw', 0.0))
        cap = float(cfg.get('cap_eur_mw_h', 0.0))
        up_thr = float(cfg.get('up_thr', 0.0))
        down_thr = float(cfg.get('down_thr', 0.0))
        if mw <= 0:
            continue

        rows = []
        cap_total = 0.0
        act_total = 0.0
        # Merge with calendar if provided
        if calendars and prod in calendars and calendars[prod] is not None and not calendars[prod].empty:
            cal = calendars[prod].copy()
            cal['date'] = pd.to_datetime(cal['date'])
            merged = df.merge(cal, on=['date', 'slot'], how='left')
            # Determine available MW per slot
            if 'available_mw' in merged.columns:
                avail_mw_series = merged['available_mw'].fillna(0.0).astype(float).clip(lower=0.0)
                avail_mw_series = avail_mw_series.apply(lambda v: min(mw, v))
            elif 'available' in merged.columns:
                avail_mw_series = merged['available'].fillna(0).astype(float) * mw
            else:
                avail_mw_series = pd.Series([mw] * len(merged), index=merged.index)
            merged['avail_mw'] = avail_mw_series
        else:
            merged = df.copy()
            merged['avail_mw'] = mw

        # Merge system imbalance if provided
        if has_imbalance:
            simbal = system_imbalance_df.copy()
            simbal['date'] = pd.to_datetime(simbal['date'])
            merged = merged.merge(simbal, on=['date','slot'], how='left')

        for month, mdf in merged.groupby('month'):
            hours_in_data = len(mdf) * 0.25

            # ===== CAPACITY REVENUE (€/MW/h) =====
            # Paid for availability regardless of activation
            # Formula: Σ(available_MW × hours_per_slot × capacity_price)
            # Example: 10 MW × 0.25h × 7.5 €/MW/h = 18.75€ per 15-min slot
            slot_cap_mw = mdf['avail_mw']
            if battery_power_mw is not None:
                slot_cap_mw = np.minimum(slot_cap_mw, float(battery_power_mw))
            cap_rev = float((slot_cap_mw * 0.25 * cap).sum())

            # ===== ACTIVATION REVENUE (€/MWh) =====
            # Paid for actual energy delivered when called upon
            # Formula: Σ(activation_price × energy_delivered_MWh)
            # Example: 210 €/MWh × 5 MWh = 1,050€ for one activation

            # Check if DAMAS actual activation data is available
            use_damas_activation = False
            damas_up_col = None
            damas_down_col = None
            damas_up_price_col = None
            damas_down_price_col = None

            # Map product names to DAMAS column names
            if prod == 'FCR' and 'fcr_activated_mwh' in mdf.columns:
                use_damas_activation = True
                damas_up_col = 'fcr_activated_mwh'
                # FCR doesn't have separate up/down prices in DAMAS
            elif prod == 'aFRR':
                if 'afrr_up_activated_mwh' in mdf.columns and 'afrr_down_activated_mwh' in mdf.columns:
                    use_damas_activation = True
                    damas_up_col = 'afrr_up_activated_mwh'
                    damas_down_col = 'afrr_down_activated_mwh'
                    damas_up_price_col = 'afrr_up_price_eur'
                    damas_down_price_col = 'afrr_down_price_eur'
            elif prod == 'mFRR':
                if 'mfrr_up_activated_mwh' in mdf.columns and 'mfrr_down_activated_mwh' in mdf.columns:
                    use_damas_activation = True
                    damas_up_col = 'mfrr_up_activated_mwh'
                    damas_down_col = 'mfrr_down_activated_mwh'
                    damas_up_price_col = 'mfrr_up_scheduled_price_eur'
                    damas_down_price_col = 'mfrr_down_scheduled_price_eur'

            if use_damas_activation:
                # USE ACTUAL TSO ACTIVATION DATA (90-95% accuracy)
                activation_method = "DAMAS_ACTUAL_TSO_ACTIVATION"

                # Masks based on actual TSO activation (not price thresholds!)
                if damas_up_col:
                    up_mask = mdf[damas_up_col].fillna(0) > 0
                else:
                    up_mask = pd.Series(False, index=mdf.index)

                if damas_down_col:
                    down_mask = mdf[damas_down_col].fillna(0) > 0
                else:
                    down_mask = pd.Series(False, index=mdf.index)

            else:
                # FALLBACK: Price-based activation is a PROXY, not actual TSO dispatch
                # Real FR energy comes from TSO activation signals, not price thresholds
                activation_method = "price_threshold_only"

                up_mask = mdf['price_eur_mwh'] >= up_thr
                down_mask = mdf['price_eur_mwh'] <= -down_thr

                if has_imbalance and ('imbalance_mw' in mdf.columns):
                    # Filter to only activate when system imbalance direction matches
                    up_mask = up_mask & (mdf['imbalance_mw'].fillna(0) > 0)
                    down_mask = down_mask & (mdf['imbalance_mw'].fillna(0) < 0)
                    activation_method = "price_threshold_with_imbalance_direction"

            # Apply per-product activation factor (0..1)
            act_factor_default = 1.0
            if activation_factor_map and prod in activation_factor_map:
                try:
                    act_factor_default = max(0.0, float(activation_factor_map.get(prod, 1.0)))
                except Exception:
                    act_factor_default = 1.0

            custom_activation = None
            if activation_curve_map and prod in activation_curve_map:
                custom_activation = activation_curve_map.get(prod)

            if custom_activation is not None and not custom_activation.empty:
                lookup_index = pd.MultiIndex.from_arrays([
                    mdf['date'].values,
                    mdf['slot'].astype(int).values,
                ])
                looked_up = custom_activation.reindex(lookup_index)
                act_factor_series = pd.Series(looked_up.values, index=mdf.index)
                act_factor_series = act_factor_series.fillna(act_factor_default).clip(lower=0.0, upper=1.0)
            else:
                act_factor_series = pd.Series(act_factor_default, index=mdf.index)

            if use_damas_activation:
                # USE ACTUAL MARKET ACTIVATION VOLUMES from DAMAS
                # Calculate our share based on market total and our contracted MW

                # Get total market activation volumes (MWh per 15-min slot)
                market_up_mwh = mdf[damas_up_col].fillna(0) if damas_up_col else pd.Series(0, index=mdf.index)
                market_down_mwh = mdf[damas_down_col].fillna(0) if damas_down_col else pd.Series(0, index=mdf.index)

                # Our maximum activation per slot (MWh)
                our_max_energy_per_slot = mdf['avail_mw'] * act_factor_series * 0.25
                if battery_power_mw is not None:
                    our_max_energy_per_slot = np.minimum(our_max_energy_per_slot, float(battery_power_mw) * 0.25)

                # Our actual activation is limited by:
                # 1. Market total activation (can't activate more than market needed)
                # 2. Our contracted capacity
                # 3. Merit-order position (not always dispatched)

                # Calculate energy per slot using market data
                energy_per_slot_up = np.minimum(our_max_energy_per_slot, market_up_mwh) * merit_order_activation_rate
                energy_per_slot_down = np.minimum(our_max_energy_per_slot, market_down_mwh) * merit_order_activation_rate

                # Combined energy series (will be split by up/down masks later)
                energy_per_slot_series = pd.Series(0.0, index=mdf.index)
                energy_per_slot_series[up_mask] = energy_per_slot_up[up_mask]
                energy_per_slot_series[down_mask] = energy_per_slot_down[down_mask]

            else:
                # FALLBACK: Price-threshold based energy calculation
                slot_act_mw = mdf['avail_mw'] * act_factor_series
                # Battery power cap during activation
                if battery_power_mw is not None:
                    slot_act_mw = np.minimum(slot_act_mw, float(battery_power_mw))
                if has_imbalance and 'imbalance_mw' in mdf.columns:
                    imbalance_cap = pd.to_numeric(mdf['imbalance_mw'], errors='coerce').abs()
                    capped = np.minimum(slot_act_mw, imbalance_cap)
                    slot_act_mw = slot_act_mw.where(imbalance_cap.isna(), capped)
                energy_per_slot_series = slot_act_mw * 0.25

                # Apply merit-order activation rate (models realistic dispatch probability)
                # This accounts for the fact that you're not always first in the merit order stack
                energy_per_slot_series = energy_per_slot_series * merit_order_activation_rate

            # Apply SOC tracking constraints if enabled and battery capacity is provided
            if enable_soc_tracking and battery_capacity_mwh and battery_capacity_mwh > 0:
                # Apply physical SOC constraints to activation energy
                actual_up_energy, actual_down_energy, soc_series = apply_soc_constraints_to_activation(
                    df=mdf.reset_index(drop=True),
                    up_mask=up_mask.reset_index(drop=True),
                    down_mask=down_mask.reset_index(drop=True),
                    energy_per_slot_mwh=energy_per_slot_series.reset_index(drop=True),
                    battery_capacity_mwh=battery_capacity_mwh,
                    initial_soc=initial_soc,
                    soc_min=soc_min,
                    soc_max=soc_max,
                    round_trip_efficiency=round_trip_efficiency,
                )
                # Overwrite planned energy with SOC-constrained energy
                energy_per_slot_series = pd.Series(0.0, index=mdf.index)
                energy_per_slot_series[up_mask] = actual_up_energy[up_mask.reset_index(drop=True)]
                energy_per_slot_series[down_mask] = actual_down_energy[down_mask.reset_index(drop=True)]

            # PRICING: Use DAMAS marginal prices when available
            if use_damas_activation and damas_up_price_col and damas_up_price_col in mdf.columns:
                # USE ACTUAL MARGINAL MARKET PRICES from DAMAS
                up_price_series = mdf[damas_up_price_col].fillna(0)
                if damas_down_price_col and damas_down_price_col in mdf.columns:
                    down_price_series = mdf[damas_down_price_col].fillna(0)
                else:
                    down_price_series = up_price_series.copy()
            else:
                # FALLBACK: Use imbalance prices or pay-as-bid prices
                price_series = mdf['price_eur_mwh']

                activation_price_mode_lower = (activation_price_mode or "market").lower()
                up_price_series = price_series.copy()
                down_price_series = price_series.copy()

                if activation_price_mode_lower == "pay_as_bid" and pay_as_bid_map and prod in pay_as_bid_map:
                    pay_prices = pay_as_bid_map.get(prod, {})
                    try:
                        up_const = float(pay_prices.get('up_price', up_price_series.mean()))
                    except Exception:
                        up_const = float(up_price_series.mean()) if not up_price_series.empty else 0.0
                    try:
                        down_const = float(pay_prices.get('down_price', up_const))
                    except Exception:
                        down_const = up_const
                    up_price_series = pd.Series(up_const, index=mdf.index)
                    down_price_series = pd.Series(down_const, index=mdf.index)

            up_rev = float((up_price_series[up_mask] * energy_per_slot_series[up_mask]).sum())
            # Per-product override for down-activation settlement sign
            prod_down_positive = pay_down_positive_map.get(prod, pay_down_as_positive) if pay_down_positive_map else pay_down_as_positive
            if prod_down_positive:
                down_rev = float((down_price_series[down_mask].abs() * energy_per_slot_series[down_mask]).sum())
            else:
                down_rev = float((down_price_series[down_mask] * energy_per_slot_series[down_mask]).sum())
            act_rev = up_rev + down_rev
            act_energy = float(energy_per_slot_series.sum())

            # Calculate net energy position for hedging
            # Up-regulation = discharge (need to buy back energy)
            # Down-regulation = charge (sell energy)
            up_energy = float(energy_per_slot_series[up_mask].sum())
            down_energy = float(energy_per_slot_series[down_mask].sum())
            net_energy = up_energy - down_energy  # Positive = net discharge, need to hedge

            # Use hedge curve when available; otherwise use average PZU price for net position
            hedge_prices = None
            if 'hedge_price_eur_mwh' in mdf.columns:
                try:
                    hedge_prices = pd.to_numeric(mdf['hedge_price_eur_mwh'], errors='coerce')
                except Exception:
                    hedge_prices = None

            if hedge_prices is not None and hedge_prices.notna().any():
                # Use slot-by-slot PZU hedge prices
                hedge_prices = hedge_prices.fillna(hedge_prices.mean())
                energy_cost = float(
                    (energy_per_slot_series[up_mask] * hedge_prices[up_mask]).sum()
                    + (energy_per_slot_series[down_mask] * hedge_prices[down_mask]).sum()
                )
            else:
                # Fallback: use monthly average PZU price for net position only
                # This avoids double-counting - you only hedge the NET energy imbalance
                avg_hedge_price = hedge_prices.mean() if hedge_prices is not None else price_series.abs().mean()
                energy_cost = float(net_energy * avg_hedge_price) if net_energy > 0 else 0.0

            # Calculate activation hours and events for debugging
            activation_slots = int(up_mask.sum() + down_mask.sum())
            activation_hours = activation_slots * 0.25

            # Count "events" as threshold crossings (transitions from inactive to active)
            combined_mask = up_mask | down_mask
            activation_events = int((combined_mask.astype(int).diff() > 0).sum())

            try:
                total_rev = cap_rev + act_rev
                cap_pct = (cap_rev / total_rev * 100) if total_rev > 0 else 0
                act_pct = (act_rev / total_rev * 100) if total_rev > 0 else 0

                print(
                    f"[FR DEBUG] {prod} {month}: "
                    f"CAPACITY={cap_rev:.2f}€ ({cap_pct:.0f}%) + "
                    f"ACTIVATION={act_rev:.2f}€ ({act_pct:.0f}%) = "
                    f"TOTAL={total_rev:.2f}€"
                )
                print(
                    f"[FR DEBUG] {prod} {month}: "
                    f"energy={act_energy:.2f}MWh hedge_cost={energy_cost:.2f}€ "
                    f"net_profit={(cap_rev + act_rev - energy_cost):.2f}€ pricing={activation_price_mode_lower}"
                )
                print(
                    f"[FR DEBUG] {prod} {month}: "
                    f"activation_hours={activation_hours:.1f}h activation_slots={activation_slots} "
                    f"activation_events={activation_events} "
                    f"up_slots={int(up_mask.sum())} down_slots={int(down_mask.sum())}"
                )
                print(
                    f"[FR DEBUG] {prod} {month}: "
                    f"up_energy={up_energy:.2f}MWh down_energy={down_energy:.2f}MWh "
                    f"net_energy={net_energy:.2f}MWh (positive=discharge)"
                )
                if activation_energy > 0:
                    avg_price = act_rev / act_energy
                    print(f"[FR DEBUG] {prod} {month}: avg_activation_price={avg_price:.2f}€/MWh")
                if hedge_prices is not None and hedge_prices.notna().any():
                    print(f"[FR DEBUG] {prod} {month}: using PZU hedge curve (avg={hedge_prices.mean():.2f}€/MWh)")
                else:
                    print(f"[FR DEBUG] {prod} {month}: using net position hedge (avg={avg_hedge_price:.2f}€/MWh)")
                print(f"[FR DEBUG] {prod} {month}: activation_method={activation_method}")
            except Exception:
                pass

            row = {
                'month': str(month),
                'hours_in_data': hours_in_data,
                'capacity_revenue_eur': cap_rev,
                'activation_revenue_eur': act_rev,
                'total_revenue_eur': cap_rev + act_rev,
                'up_slots': int(up_mask.sum()),
                'down_slots': int(down_mask.sum()),
                'activation_energy_mwh': act_energy,
                'energy_cost_eur': energy_cost,
            }
            rows.append(row)
            cap_total += cap_rev
            act_total += act_rev

            # Update combined monthly
            mkey = str(month)
            agg = combined_month_map.setdefault(mkey, {
                'month': mkey,
                'hours_in_data': 0.0,
                'capacity_revenue_eur': 0.0,
                'activation_revenue_eur': 0.0,
                'total_revenue_eur': 0.0,
                'up_slots': 0,
                'down_slots': 0,
                'activation_energy_mwh': 0.0,
                'energy_cost_eur': 0.0,
            })
            agg['hours_in_data'] = max(agg['hours_in_data'], hours_in_data)
            agg['capacity_revenue_eur'] += cap_rev
            agg['activation_revenue_eur'] += act_rev
            agg['total_revenue_eur'] += (cap_rev + act_rev)
            agg['up_slots'] += int(up_mask.sum())
            agg['down_slots'] += int(down_mask.sum())
            agg['activation_energy_mwh'] += act_energy
            agg['energy_cost_eur'] += energy_cost

        rows.sort(key=lambda x: x['month'])
        monthly_by_product[prod] = rows
        totals_by_product[prod] = {
            'capacity_revenue_eur': cap_total,
            'activation_revenue_eur': act_total,
            'total_revenue_eur': cap_total + act_total,
            'energy_cost_eur': float(sum(r['energy_cost_eur'] for r in rows)),
            'months': len(rows),
        }

    combined_monthly = sorted(combined_month_map.values(), key=lambda x: x['month'])
    comb_cap = sum(r['capacity_revenue_eur'] for r in combined_monthly)
    comb_act = sum(r['activation_revenue_eur'] for r in combined_monthly)
    comb_cost = sum(r.get('energy_cost_eur', 0.0) for r in combined_monthly)
    combined_totals = {
        'capacity_revenue_eur': comb_cap,
        'activation_revenue_eur': comb_act,
        'total_revenue_eur': comb_cap + comb_act,
        'energy_cost_eur': comb_cost,
        'months': len(combined_monthly),
    }

    try:
        comb_energy = sum(r.get('activation_energy_mwh', 0.0) for r in combined_monthly)
        print(
            f"[FR DEBUG] Combined totals: cap={comb_cap:.2f}€ act={comb_act:.2f}€ energy={comb_energy:.2f}MWh hedge_cost={comb_cost:.2f}€ months={len(combined_monthly)}",
        )
    except Exception:
        pass

    return {
        'monthly_by_product': monthly_by_product,
        'totals_by_product': totals_by_product,
        'combined_monthly': combined_monthly,
        'combined_totals': combined_totals,
    }

@st.cache_data(show_spinner=False)
def analyze_pzu_best_hours(pzu_csv: str, start_year: int = 2023, window_months: int = 12) -> Dict:
    """Compute hour-of-day average prices and best buy/sell hours over a historical window."""
    if not pzu_csv or not Path(pzu_csv).exists():
        return {'error': 'PZU CSV not found'}
    try:
        df = pd.read_csv(pzu_csv)
        df['date'] = pd.to_datetime(df['date'])
        df['month'] = df['date'].dt.to_period('M')
        df = df[df['date'] >= pd.Timestamp(year=start_year, month=1, day=1)]
        # keep last N months
        months_sorted = sorted(df['month'].unique())
        if not months_sorted:
            return {'error': 'No months found after filtering'}
        chosen = months_sorted[-window_months:]
        df = df[df['month'].isin(chosen)]
        # ensure full 24h days
        full_days = df.groupby('date')['hour'].count()
        valid_dates = full_days[full_days >= 24].index
        dfd = df[df['date'].isin(valid_dates)]
        # average by hour-of-day
        avg_by_hour = dfd.groupby('hour')['price'].mean().reindex(range(24)).fillna(method='ffill').fillna(method='bfill')
        # best hours: lowest 3 and highest 3
        best_buy = avg_by_hour.nsmallest(3)
        best_sell = avg_by_hour.nlargest(3)
        spread = float(best_sell.iloc[0] - best_buy.iloc[0])
        return {
            'window_months': len(chosen),
            'hours': list(range(24)),
            'avg_price_by_hour': [float(x) for x in avg_by_hour.values],
            'best_buy_hours': [{'hour': int(h), 'avg_price': float(v)} for h, v in best_buy.items()],
            'best_sell_hours': [{'hour': int(h), 'avg_price': float(v)} for h, v in best_sell.items()],
            'avg_spread_top_vs_bottom': spread,
            'start_month': str(chosen[0]) if chosen else None,
            'end_month': str(chosen[-1]) if chosen else None,
        }
    except Exception as e:
        return {'error': f'Failed to analyze PZU best hours: {e}'}

@st.cache_data(show_spinner=False)
def analyze_pzu_best_hours_min_years(
    pzu_csv: str,
    min_years: int = 3,
    round_trip_efficiency: float = 0.9,
    capacity_mwh: float = 0.0,
    investment_eur: float = 6_500_000,
) -> Dict:
    """Detect best buy/sell hours using minimum N years of PZU history and estimate arbitrage profits.
    Picks the hour-of-day with lowest average price as BUY and highest as SELL across the whole period.
    Returns daily and annual profit estimates (assuming one cycle/day), plus optional ROI.
    """
    if not pzu_csv or not Path(pzu_csv).exists():
        return {'error': 'PZU CSV not found'}
    try:
        df = pd.read_csv(pzu_csv)
        if not {'date','hour','price'}.issubset(df.columns):
            return {'error': 'PZU CSV must contain columns: date,hour,price'}
        df['date'] = pd.to_datetime(df['date'])
        months = df['date'].dt.to_period('M').unique()
        total_months = len(months)
        if total_months < (min_years * 12):
            return {
                'error': f'Insufficient history: found {total_months} months, need at least {min_years*12} months',
                'suggestion': 'Point pzu_forecast_csv to a >=3-year history (e.g., data/pzu_history_3y.csv)'
            }
        # Aggregate averages by hour-of-day over full history
        df_sorted = df.sort_values(['date','hour'])
        hourly_avg = df_sorted.groupby('hour')['price'].mean().reindex(range(24))
        buy_hour = int(hourly_avg.idxmin())
        sell_hour = int(hourly_avg.idxmax())
        avg_buy = float(hourly_avg.min())
        avg_sell = float(hourly_avg.max())
        # Correct: Profit = (sell_price × η - buy_price) × capacity
        net_spread = avg_sell * float(round_trip_efficiency) - avg_buy
        daily_profit = max(0.0, net_spread) * float(capacity_mwh)
        annual_profit = daily_profit * 365.0
        roi_percent = (annual_profit / float(investment_eur) * 100.0) if investment_eur and investment_eur > 0 else 0.0
        payback_years = (float(investment_eur) / annual_profit) if annual_profit > 0 else float('inf')
        return {
            'analysis_type': f'{min_years}-Year Best-Hour Arbitrage Estimate',
            'period_months': total_months,
            'data_period': f"{df['date'].min().date()} to {df['date'].max().date()}",
            'buy_hour': buy_hour,
            'sell_hour': sell_hour,
            'avg_buy_eur_mwh': avg_buy,
            'avg_sell_eur_mwh': avg_sell,
            'net_spread_eur_mwh': net_spread,
            'daily_profit_eur': daily_profit,
            'annual_profit_eur': annual_profit,
            'roi_annual_percent': roi_percent,
            'payback_years': payback_years,
        }
    except Exception as e:
        return {'error': f'Failed 3-year best-hour analysis: {e}'}

@st.cache_data(show_spinner=False)
def estimate_pzu_profit_window(
    pzu_csv: str,
    capacity_mwh: float,
    round_trip_efficiency: float = 0.9,
    days: Optional[int] = None,
    months: Optional[int] = None,
) -> Dict:
    """Estimate profit over the last N days or last N months using a simple daily min/max arbitrage.
    Returns used_days, used_months, total_profit_eur, avg_daily_profit_eur, annualized_profit_eur, data_period.
    """
    if not pzu_csv or not Path(pzu_csv).exists():
        return {'error': 'PZU CSV not found'}
    try:
        df = pd.read_csv(pzu_csv)
        if not {'date','hour','price'}.issubset(df.columns):
            return {'error': 'PZU CSV must contain columns: date,hour,price'}
        df['date'] = pd.to_datetime(df['date'])
        df = df.sort_values(['date','hour'])
        # Window selection
        used_months = 0
        if months is not None:
            uniq_months = sorted(df['date'].dt.to_period('M').unique())
            if len(uniq_months) == 0:
                return {'error': 'No months in dataset'}
            chosen = uniq_months[-int(months):]
            df = df[df['date'].dt.to_period('M').isin(chosen)]
            used_months = len(chosen)
        elif days is not None:
            uniq_days = sorted(df['date'].dt.date.unique())
            if len(uniq_days) == 0:
                return {'error': 'No days in dataset'}
            chosen_days = uniq_days[-int(days):]
            df = df[df['date'].dt.date.isin(chosen_days)]
        # Group by day and compute daily profit
        eta = float(round_trip_efficiency)
        cap = float(capacity_mwh)
        daily_profits: List[float] = []
        for _date, g in df.groupby(df['date'].dt.date):
            day_prices = g.sort_values('hour')['price']
            if len(day_prices) < 4:
                continue
            min_p = float(day_prices.min())
            max_p = float(day_prices.max())
            net = max_p - (min_p / eta)
            daily_profits.append(max(0.0, net) * cap)
        used_days = len(daily_profits)
        total_profit = float(sum(daily_profits))
        avg_daily = (total_profit / used_days) if used_days > 0 else 0.0
        # Annualize based on days covered
        annualized = avg_daily * 365.0
        period = f"{df['date'].min().date()} to {df['date'].max().date()}"
        return {
            'used_days': used_days,
            'used_months': used_months,
            'total_profit_eur': total_profit,
            'avg_daily_profit_eur': avg_daily,
            'annualized_profit_eur': annualized,
            'data_period': period,
        }
    except Exception as e:
        return {'error': f'Failed profit estimation: {e}'}

@st.cache_data(show_spinner=False)
def plan_multi_hour_strategy_from_history(
    pzu_csv: str,
    min_years: int,
    round_trip_efficiency: float,
    capacity_mwh: float,
    power_mw: float,
    buy_hours_buffer: int,
    sell_hours_buffer: int,
    cycles_per_day: int = 1,
    investment_eur: float = 6_500_000,
) -> Dict:
    """Plan a simple daily arbitrage using hour-of-day averages over >= N years.
    - Picks k lowest-avg hours for charging and k' highest-avg hours for discharging
    - Respects power and capacity, round-trip efficiency, and cycles/day budget
    - Approximates profit using average prices for chosen hours
    """
    if not pzu_csv or not Path(pzu_csv).exists():
        return {'error': 'PZU CSV not found'}
    try:
        df = pd.read_csv(pzu_csv)
        if not {'date','hour','price'}.issubset(df.columns):
            return {'error': 'PZU CSV must contain columns: date,hour,price'}
        df['date'] = pd.to_datetime(df['date'])
        months = df['date'].dt.to_period('M').unique()
        if len(months) < (min_years * 12):
            return {'error': f'Insufficient history: need >= {min_years} years'},
        hourly_avg = df.groupby('hour')['price'].mean().reindex(range(24))
        k_b = max(1, int(buy_hours_buffer))
        k_s = max(1, int(sell_hours_buffer))
        buy_hours = list(hourly_avg.nsmallest(k_b).index.astype(int))
        sell_hours = list(hourly_avg.nlargest(k_s).index.astype(int))
        avg_buy = float(hourly_avg.iloc[buy_hours].mean()) if k_b > 0 else float('nan')
        avg_sell = float(hourly_avg.iloc[sell_hours].mean()) if k_s > 0 else float('nan')
        e = float(round_trip_efficiency)
        cap = float(capacity_mwh)
        P = float(power_mw)
        # Energy per cycle limited by power windows and capacity + efficiency
        max_discharge_by_power = P * k_s
        max_charge_by_power = P * k_b
        max_discharge_by_capacity = e * min(cap, max_charge_by_power)
        E_discharge = max(0.0, min(max_discharge_by_power, max_discharge_by_capacity))
        # Profit per cycle based on prices
        profit_per_cycle = E_discharge * avg_sell - (E_discharge / e) * avg_buy if E_discharge > 0 else 0.0
        # Cycles/day limited by available hours
        max_cycles_by_hours = max(1, 24 // (k_b + k_s))
        cycles_used = max(1, min(int(cycles_per_day), int(max_cycles_by_hours)))
        daily_profit = profit_per_cycle * cycles_used
        annual_profit = daily_profit * 365.0
        roi_percent = (annual_profit / float(investment_eur) * 100.0) if investment_eur and annual_profit > 0 else 0.0
        payback_years = (float(investment_eur) / annual_profit) if annual_profit > 0 else float('inf')
        return {
            'analysis_type': f'{min_years}y Hour-of-day buffer strategy',
            'buy_hours': buy_hours,
            'sell_hours': sell_hours,
            'avg_buy_eur_mwh': avg_buy,
            'avg_sell_eur_mwh': avg_sell,
            'energy_sold_mwh_per_cycle': E_discharge,
            'profit_per_cycle_eur': profit_per_cycle,
            'cycles_used_per_day': cycles_used,
            'daily_profit_eur': daily_profit,
            'annual_profit_eur': annual_profit,
            'roi_annual_percent': roi_percent,
            'payback_years': payback_years,
        }
    except Exception as e:
        return {'error': f'Failed multi-hour strategy planning: {e}'}

def render_historical_market_comparison(cfg: dict, capacity_mwh: float, eta_rt: float) -> None:
    """Render comparison using cached results from PZU Horizons and FR Simulator."""
    st.caption("This comparison reuses the most recent runs of the PZU Horizons and FR Simulator views.")

    pzu_metrics = st.session_state.get("pzu_market_metrics")
    if not pzu_metrics or not isinstance(pzu_metrics, dict) or "daily_history" not in pzu_metrics:
        st.info("Run the PZU Horizons view and recompute results to populate comparison data.")
        return

    daily_history_raw = pzu_metrics.get("daily_history")
    if daily_history_raw is None:
        st.info("No PZU profitability data available. Run PZU Horizons first.")
        return

    if isinstance(daily_history_raw, pd.DataFrame):
        daily_history = daily_history_raw.copy()
    else:
        daily_history = pd.DataFrame(daily_history_raw)

    if daily_history.empty:
        st.info("No PZU profitability data available. Run PZU Horizons first.")
        return

    daily_history["date"] = pd.to_datetime(daily_history["date"], errors="coerce")
    daily_history = daily_history.dropna(subset=["date"]).sort_values("date")
    pzu_monthly = (
        daily_history.assign(month=daily_history["date"].dt.to_period("M"))
        .groupby("month", as_index=False)["daily_profit_eur"]
        .sum()
        .rename(columns={"daily_profit_eur": "total_profit_eur"})
    )
    pzu_monthly["month"] = pzu_monthly["month"].astype(str)
    total_months = len(pzu_monthly)
    if total_months == 0:
        st.info("No monthly PZU data available for comparison.")
        return

    default_window = min(12, total_months)
    window = st.slider("Window (months)", min_value=1, max_value=total_months, value=default_window, step=1)

    pzu_window = pzu_monthly.tail(window).reset_index(drop=True)
    pzu_total_profit = float(pzu_window["total_profit_eur"].sum())
    pzu_annualized_profit = pzu_total_profit * (12.0 / len(pzu_window)) if len(pzu_window) else 0.0

    fr_metrics = st.session_state.get("fr_market_metrics")
    fr_window = pd.DataFrame()
    fr_total_revenue = 0.0
    fr_annualized_revenue = 0.0
    if isinstance(fr_metrics, dict) and fr_metrics.get("months"):
        fr_months_df = pd.DataFrame(fr_metrics["months"])
        if not fr_months_df.empty and "month" in fr_months_df.columns:
            try:
                fr_months_df["month_period"] = pd.PeriodIndex(fr_months_df["month"], freq="M")
            except Exception:
                fr_months_df["month_period"] = pd.to_datetime(fr_months_df["month"], errors="coerce").dt.to_period("M")
            fr_months_df = fr_months_df.dropna(subset=["month_period"]).sort_values("month_period")
            fr_months_df["month"] = fr_months_df["month_period"].astype(str)

            # Fill months without activation entries using averages from observed months
            for col in ["energy_cost_eur", "activation_revenue_eur", "activation_energy_mwh"]:
                if col in fr_months_df.columns:
                    fr_months_df[col] = pd.to_numeric(fr_months_df[col], errors="coerce")

            cost_mask = fr_months_df.get("energy_cost_eur", pd.Series(dtype=float)).fillna(0.0) > 0.0
            if cost_mask.any():
                avg_cost = fr_months_df.loc[cost_mask, "energy_cost_eur"].mean()
                fr_months_df.loc[~cost_mask, "energy_cost_eur"] = avg_cost

            act_mask = fr_months_df.get("activation_revenue_eur", pd.Series(dtype=float)).fillna(0.0) > 0.0
            if act_mask.any():
                avg_act = fr_months_df.loc[act_mask, "activation_revenue_eur"].mean()
                fr_months_df.loc[~act_mask, "activation_revenue_eur"] = avg_act

            energy_mask = fr_months_df.get("activation_energy_mwh", pd.Series(dtype=float)).fillna(0.0) > 0.0
            if energy_mask.any():
                avg_energy = fr_months_df.loc[energy_mask, "activation_energy_mwh"].mean()
                fr_months_df.loc[~energy_mask, "activation_energy_mwh"] = avg_energy

            if {"capacity_revenue_eur", "activation_revenue_eur"}.issubset(fr_months_df.columns):
                fr_months_df["total_revenue_eur"] = (
                    fr_months_df["capacity_revenue_eur"].fillna(0.0)
                    + fr_months_df["activation_revenue_eur"].fillna(0.0)
                )

            window_fr = min(window, len(fr_months_df))
            if window_fr > 0:
                fr_window = fr_months_df.tail(window_fr).reset_index(drop=True)
                fr_total_revenue = float(fr_window["total_revenue_eur"].sum())
                fr_annualized_revenue = fr_total_revenue * (12.0 / window_fr)

    st.subheader("Aggregated Results")
    col1, col2 = st.columns(2)
    with col1:
        st.markdown("**OPCOM PZU (Arbitrage)**")
        st.metric("Total profit (window)", format_currency(pzu_total_profit, decimals=currency_decimals, thousands=thousands_sep))
        st.metric("Annualized profit", format_currency(pzu_annualized_profit, decimals=currency_decimals, thousands=thousands_sep))
        st.caption(
            "Months used: "
            + ", ".join(pzu_window["month"].tolist())
            if not pzu_window.empty
            else "No months selected"
        )
    with col2:
        st.markdown("**FR Revenue (TRANSELECTRICA)**")
        if not fr_window.empty:
            st.metric("Total revenue (window)", format_currency(fr_total_revenue, decimals=currency_decimals, thousands=thousands_sep))
            st.metric("Annualized revenue", format_currency(fr_annualized_revenue, decimals=currency_decimals, thousands=thousands_sep))
            window_energy_cost = float(fr_window.get("energy_cost_eur", 0.0).sum())
            st.metric(
                "Energy cost (window)",
                format_currency(window_energy_cost, decimals=currency_decimals, thousands=thousands_sep),
            )
            fr_net_margin = fr_total_revenue - window_energy_cost
            st.metric(
                "Net profit (window)",
                format_currency(fr_net_margin, decimals=currency_decimals, thousands=thousands_sep),
            )
            st.caption(
                "Months used: "
                + ", ".join(fr_window["month"].tolist())
            )
        else:
            st.info("FR Simulator data unavailable for the selected window.")

    st.subheader("PZU Monthly Detail")
    pzu_display = pzu_window.rename(columns={"month": "Month", "total_profit_eur": "Profit €"})
    pzu_display["Profit €"] = pzu_display["Profit €"].apply(
        lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep)
    )
    st.dataframe(pzu_display, width='stretch')

    if not fr_window.empty:
        st.subheader("FR Monthly Detail")
        fr_display = fr_window.rename(
            columns={
                "month": "Month",
                "capacity_revenue_eur": "Capacity €",
                "activation_revenue_eur": "Activation €",
                "total_revenue_eur": "Total €",
            }
        )
        if "activation_energy_mwh" in fr_window.columns:
            fr_display["Energy MWh"] = fr_window["activation_energy_mwh"].map(lambda v: f"{float(v):.2f}")
        fr_display["Energy cost €"] = fr_window.get("energy_cost_eur", 0.0).apply(
            lambda v: format_currency(float(v), decimals=currency_decimals, thousands=thousands_sep)
        )
        for col in ["Capacity €", "Activation €", "Total €"]:
            fr_display[col] = fr_display[col].apply(
                lambda v: format_currency(v, decimals=currency_decimals, thousands=thousands_sep)
            )
        st.dataframe(fr_display, width='stretch')

        annual_info = fr_metrics.get("annual") if isinstance(fr_metrics, dict) else None
        three_year_info = fr_metrics.get("three_year") if isinstance(fr_metrics, dict) else None

        if annual_info:
            annual_table = pd.DataFrame(
                [
                    ("Capacity revenue (12m)", format_currency(annual_info.get("capacity", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Activation revenue (12m)", format_currency(annual_info.get("activation", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Total revenue (12m)", format_currency(annual_info.get("total", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Energy cost (12m)", format_currency(annual_info.get("energy_cost", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Debt service (12m)", format_currency(annual_info.get("debt", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Net profit (12m)", format_currency(annual_info.get("net", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                ],
                columns=["Metric", "Value"],
            )
            st.subheader("FR Annual Cash Flow (from simulator)")
            st.table(annual_table)
            source_months = annual_info.get("source_months")
            if source_months and source_months < 12:
                st.caption(f"Scaled from last {int(source_months)} month(s) of FR data.")

        if three_year_info:
            outlook_table = pd.DataFrame(
                [
                    ("Capacity revenue (3y sim)", format_currency(three_year_info.get("capacity", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Activation revenue (3y sim)", format_currency(three_year_info.get("activation", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Total revenue (3y sim)", format_currency(three_year_info.get("total", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Energy cost (3y)", format_currency(three_year_info.get("energy_cost", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Debt service (3y)", format_currency(three_year_info.get("debt", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                    ("Net profit (3y sim)", format_currency(three_year_info.get("net", 0.0), decimals=currency_decimals, thousands=thousands_sep)),
                ],
                columns=["Metric", "Value"],
            )
            st.subheader("FR Simulated 3-Year Outlook (from simulator)")
            st.table(outlook_table)
def render_frequency_regulation_simulator(cfg: dict) -> None:
    """Render the FR simulator UI (TRANSELECTRICA) with per-product split and optional calendars."""
    st.subheader("⚡ Frequency Regulation Revenue Simulator (TRANSELECTRICA)")
    st.caption("Models grid services revenue: capacity (€/MW/h) + activation (€/MWh). No arbitrage.")

    st.caption(
        "This simulator consumes Transelectrica’s **DAMAS activation dataset** when available (aFRR/mFRR energy + marginal prices). "
        "If the dataset is missing it falls back to the legacy price-threshold proxy, which is far less accurate."
    )

    with st.expander("What is this and how it works?", expanded=False):
        st.markdown(
            "- Operator: TRANSELECTRICA (TSO). Purpose: grid frequency regulation, not energy trading.\n"
            "- Inputs: contracted MW per product (FCR/aFRR/mFRR) and capacity €/MW/h.\n"
            "- Capacity revenue: Σ(available_MW × 0.25 h × capacity_price) over all 15‑minute slots.\n"
            "- Activation revenue: uses **actual DAMAS aFRR/mFRR energy + marginal prices** when the dataset is present.\n"
            "- Fallback: if DAMAS data is missing you can load legacy export‑8 files and the model reverts to the price-threshold proxy.\n"
            "- Data sources: `data/imbalance_history.csv` / `damas_complete_fr_dataset.csv` (built via DAMAS downloader).\n"
            "- Accuracy: DAMAS ≈ 90‑95% vs settlement; price proxy ≈ 60‑75%."
        )

    fr_cfg = cfg.get('fr_products', {}) if cfg else {}
    data_cfg = cfg.get('data', {}) if cfg else {}
    cfg_fx = float(data_cfg.get('fx_ron_per_eur', 5.0))

    sample_export8 = project_root / "data" / "export-8-sample.xlsx"
    sample_sysimb = project_root / "data" / "Estimated power system imbalance.xlsx"
    corrected_imbalance = project_root / "data" / "imbalance_history_corrected.csv"
    default_export8 = (
        str(corrected_imbalance)
        if corrected_imbalance.exists()
        else (
            "export-8.xlsx"
            if Path("export-8.xlsx").exists()
            else (
                "downloads/transelectrica_imbalance/export-8.xlsx"
                if Path("downloads/transelectrica_imbalance/export-8.xlsx").exists()
                else (str(sample_export8) if sample_export8.exists() else (
                    find_in_data_dir([
                        r"export-8\\.xlsx",
                        r"export_8\\.xlsx",
                        r"estimated.*price.*xlsx",
                        r"price.*imbalance.*xlsx",
                    ])
                    or ""
                ))
            )
        )
    )
    colx1, colx2 = st.columns([2, 1])
    with colx1:
        price_candidates = list_in_data_dir([r"imbalance_history_corrected\\.csv", r"export[-_]?8\\.xlsx", r"estimated.*price.*xlsx", r"price.*imbalance.*xlsx", r"imbalance.*price.*csv"]) or []
        if not price_candidates:
            price_candidates = list_in_data_dir([r".*\\.xlsx$", r".*\\.xls$"]) or []
        selected_price = st.selectbox("Detected price files", options=["(none)"] + price_candidates, key='fr_price_detect')
        if 'fr_price_path' not in st.session_state:
            st.session_state['fr_price_path'] = default_export8 or (price_candidates[0] if price_candidates else "")
        use_sel_price = st.button("Use selected price", key='fr_use_price')
        if use_sel_price and selected_price != "(none)":
            st.session_state['fr_price_path'] = selected_price
        export8_path = st.text_input("Path to export-8 Excel or folder", key='fr_price_path')

        # Notify user if corrected imbalance data is being used
        if export8_path and "imbalance_history_corrected.csv" in export8_path:
            st.info("✅ Using corrected imbalance data (RON→EUR conversion + 10x error fix applied). See DATA_VALIDATION_REPORT.md for details.")

        sysimb_candidates = list_in_data_dir([
            r"estimated.*power.*system.*imbalance",
            r"power.*system.*imbalance",
            r"imbalance.*system.*xlsx",
            r"imbalance.*system.*csv",
        ]) or []
        if not sysimb_candidates:
            sysimb_candidates = list_in_data_dir([r".*\\.xlsx$", r".*\\.xls$", r".*\\.csv$"]) or []
        selected_sysimb = st.selectbox(
            "Detected system imbalance files",
            options=["(none)"] + sysimb_candidates,
            key='fr_sysimb_detect',
        )
        if 'fr_sysimb_path' not in st.session_state:
            default_sysimb = ""
            if sample_sysimb.exists():
                default_sysimb = str(sample_sysimb)
            else:
                default_sysimb = find_in_data_dir([
                    r"estimated.*power.*system.*imbalance",
                    r"imbalance.*power.*system",
                ]) or ""
            st.session_state['fr_sysimb_path'] = default_sysimb
        use_sel_sysimb = st.button("Use selected imbalance", key='fr_use_sysimb')
        if use_sel_sysimb and selected_sysimb != "(none)":
            st.session_state['fr_sysimb_path'] = selected_sysimb
        sysimb_path = st.text_input("System imbalance Excel/folder", key='fr_sysimb_path')

    with colx2:
        excel_currency = st.selectbox("Excel currency", options=["RON","EUR"], index=0)
        fx_rate = st.number_input("FX RON/EUR", min_value=1.0, max_value=10.0, value=cfg_fx, step=0.1, help="Used if Excel prices are in RON/MWh")

    pay_down_positive = st.checkbox("Pay down‑activation as positive", value=True, help="If off, negative prices reduce revenue. Some products may be settled differently; this toggle lets you choose.")

    st.markdown("---")
    st.caption("Per-product settings (enable at least one):")
    e1, e2, e3 = st.columns(3)
    with e1:
        fcrd = fr_cfg.get('FCR', {})
        fcr_enabled = st.checkbox("Enable FCR", value=bool(fcrd.get('enabled', True)))
        fcr_mw = st.number_input("FCR MW (contracted)", min_value=0.0, max_value=200.0, value=float(fcrd.get('contracted_mw', 10.0)), step=1.0, help="MW reserved/contracted for FCR")
        fcr_cap = st.number_input("FCR capacity €/MW/h", min_value=0.0, max_value=1000.0, value=float(fcrd.get('capacity_eur_per_mw_h', 7.5)), step=0.5, help="Availability payment per MW per hour")
        fcr_up = st.number_input("FCR up threshold €/MWh", min_value=0.0, max_value=500.0, value=float(fcrd.get('up_threshold_eur_mwh', 0.0)), step=1.0, help="Min price to count up‑activation")
        fcr_down = st.number_input("FCR down threshold €/MWh", min_value=0.0, max_value=500.0, value=float(fcrd.get('down_threshold_eur_mwh', 0.0)), step=1.0, help="Min |price| to count down‑activation")
        fcr_down_pos = st.checkbox("FCR: down‑activation paid positive", value=True, help="Treat down regulation energy as positive revenue (|price| × energy)")
        fcr_act = st.number_input("FCR activation factor (0–1)", min_value=0.0, max_value=1.0, value=0.05, step=0.01, help="Scales activation energy to a realistic duty factor")
    with e2:
        afrrd = fr_cfg.get('aFRR', {})
        afrr_enabled = st.checkbox("Enable aFRR", value=bool(afrrd.get('enabled', True)))
        afrr_mw = st.number_input("aFRR MW (contracted)", min_value=0.0, max_value=200.0, value=float(afrrd.get('contracted_mw', 10.0)), step=1.0, help="MW reserved/contracted for aFRR")
        afrr_cap = st.number_input("aFRR capacity €/MW/h", min_value=0.0, max_value=1000.0, value=float(afrrd.get('capacity_eur_per_mw_h', 5.0)), step=0.5, help="Availability payment per MW per hour")
        afrr_up = st.number_input("aFRR up threshold €/MWh", min_value=0.0, max_value=500.0, value=float(afrrd.get('up_threshold_eur_mwh', 0.0)), step=1.0, help="Min price to count up‑activation")
        afrr_down = st.number_input("aFRR down threshold €/MWh", min_value=0.0, max_value=500.0, value=float(afrrd.get('down_threshold_eur_mwh', 0.0)), step=1.0, help="Min |price| to count down‑activation")
        afrr_down_pos = st.checkbox("aFRR: down‑activation paid positive", value=True)
        afrr_act = st.number_input("aFRR activation factor (0–1)", min_value=0.0, max_value=1.0, value=0.10, step=0.01)
    with e3:
        mfrrd = fr_cfg.get('mFRR', {})
        mfrr_enabled = st.checkbox("Enable mFRR", value=bool(mfrrd.get('enabled', False)))
        mfrr_mw = st.number_input("mFRR MW (contracted)", min_value=0.0, max_value=200.0, value=float(mfrrd.get('contracted_mw', 0.0)), step=1.0, help="MW reserved/contracted for mFRR")
        mfrr_cap = st.number_input("mFRR capacity €/MW/h", min_value=0.0, max_value=1000.0, value=float(mfrrd.get('capacity_eur_per_mw_h', 0.0)), step=0.5, help="Availability payment per MW per hour")
        mfrr_up = st.number_input("mFRR up threshold €/MWh", min_value=0.0, max_value=500.0, value=float(mfrrd.get('up_threshold_eur_mwh', 0.0)), step=1.0, help="Min price to count up‑activation")
        mfrr_down = st.number_input("mFRR down threshold €/MWh", min_value=0.0, max_value=500.0, value=float(mfrrd.get('down_threshold_eur_mwh', 0.0)), step=1.0, help="Min |price| to count down‑activation")
        mfrr_down_pos = st.checkbox("mFRR: down‑activation paid positive", value=True)
        mfrr_act = st.number_input("mFRR activation factor (0–1)", min_value=0.0, max_value=1.0, value=0.10, step=0.01)

    products_cfg = {
        'FCR': {'enabled': fcr_enabled, 'mw': fcr_mw, 'cap_eur_mw_h': fcr_cap, 'up_thr': fcr_up, 'down_thr': fcr_down},
        'aFRR': {'enabled': afrr_enabled, 'mw': afrr_mw, 'cap_eur_mw_h': afrr_cap, 'up_thr': afrr_up, 'down_thr': afrr_down},
        'mFRR': {'enabled': mfrr_enabled, 'mw': mfrr_mw, 'cap_eur_mw_h': mfrr_cap, 'up_thr': mfrr_up, 'down_thr': mfrr_down},
    }
    paydown_map = {'FCR': fcr_down_pos, 'aFRR': afrr_down_pos, 'mFRR': mfrr_down_pos}
    act_map = {'FCR': fcr_act, 'aFRR': afrr_act, 'mFRR': mfrr_act}

    ref_cols = st.columns(3)
    with ref_cols[0]:
        fcr_ref_mw = st.number_input(
            "FCR activation reference MW",
            min_value=1.0,
            max_value=2000.0,
            value=float(fr_cfg.get('FCR', {}).get('activation_reference_mw', 50.0)),
            step=1.0,
            help="Approximate total MW of imbalance reserve to normalise FCR activation factors.",
        )
    with ref_cols[1]:
        afrr_ref_mw = st.number_input(
            "aFRR activation reference MW",
            min_value=1.0,
            max_value=2000.0,
            value=float(fr_cfg.get('aFRR', {}).get('activation_reference_mw', 80.0)),
            step=1.0,
        )
    with ref_cols[2]:
        mfrr_ref_mw = st.number_input(
            "mFRR activation reference MW",
            min_value=1.0,
            max_value=2000.0,
            value=float(fr_cfg.get('mFRR', {}).get('activation_reference_mw', 120.0)),
            step=1.0,
        )

    smoothing_option = st.selectbox(
        "Activation profile smoothing",
        options=["Per ISP", "Monthly average"],
        index=1,
        help="Whether to average activation factors per 15-min slot or by month to reduce volatility.",
    )

    pricing_mode_label = st.selectbox(
        "Activation pricing mode",
        options=["Pay-as-bid (manual)", "Market prices (export data)"]
    )
    activation_price_mode = "pay_as_bid" if pricing_mode_label == "Pay-as-bid (manual)" else "market"

    pay_as_bid_map: Dict[str, Dict[str, float]] = {}
    if activation_price_mode == "pay_as_bid":
        st.caption("Enter the accepted pay-as-bid activation prices (€/MWh) for each product.")
        pay_cols = st.columns(3)
        with pay_cols[0]:
            fcr_up_price = st.number_input(
                "FCR up €/MWh",
                min_value=0.0,
                max_value=1000.0,
                value=float(fr_cfg.get('FCR', {}).get('pay_as_bid_up', 80.0)),
                step=1.0,
            )
            fcr_down_price = st.number_input(
                "FCR down €/MWh",
                min_value=-1000.0,
                max_value=1000.0,
                value=float(fr_cfg.get('FCR', {}).get('pay_as_bid_down', 80.0)),
                step=1.0,
            )
            pay_as_bid_map['FCR'] = {'up_price': fcr_up_price, 'down_price': fcr_down_price}
        with pay_cols[1]:
            afrr_up_price = st.number_input(
                "aFRR up €/MWh",
                min_value=0.0,
                max_value=1000.0,
                value=float(fr_cfg.get('aFRR', {}).get('pay_as_bid_up', 90.0)),
                step=1.0,
            )
            afrr_down_price = st.number_input(
                "aFRR down €/MWh",
                min_value=-1000.0,
                max_value=1000.0,
                value=float(fr_cfg.get('aFRR', {}).get('pay_as_bid_down', 90.0)),
                step=1.0,
            )
            pay_as_bid_map['aFRR'] = {'up_price': afrr_up_price, 'down_price': afrr_down_price}
        with pay_cols[2]:
            mfrr_up_price = st.number_input(
                "mFRR up €/MWh",
                min_value=0.0,
                max_value=1000.0,
                value=float(fr_cfg.get('mFRR', {}).get('pay_as_bid_up', 100.0)),
                step=1.0,
            )
            mfrr_down_price = st.number_input(
                "mFRR down €/MWh",
                min_value=-1000.0,
                max_value=1000.0,
                value=float(fr_cfg.get('mFRR', {}).get('pay_as_bid_down', 100.0)),
                step=1.0,
            )
            pay_as_bid_map['mFRR'] = {'up_price': mfrr_up_price, 'down_price': mfrr_down_price}

    st.caption("Optional availability calendars (CSV/XLSX). Columns: date, slot, available_mw or available(0/1).")
    cal1, cal2, cal3 = st.columns(3)
    with cal1:
        fcr_cal_path = st.text_input("FCR calendar path", value=str(fr_cfg.get('FCR', {}).get('calendar_csv', "")))
        fcr_cal_upload = st.file_uploader("Upload FCR calendar", type=['csv','xlsx','xls'], key='fcr_cal')
    with cal2:
        afrr_cal_path = st.text_input("aFRR calendar path", value=str(fr_cfg.get('aFRR', {}).get('calendar_csv', "")))
        afrr_cal_upload = st.file_uploader("Upload aFRR calendar", type=['csv','xlsx','xls'], key='afrr_cal')
    with cal3:
        mfrr_cal_path = st.text_input("mFRR calendar path", value=str(fr_cfg.get('mFRR', {}).get('calendar_csv', "")))
        mfrr_cal_upload = st.file_uploader("Upload mFRR calendar", type=['csv','xlsx','xls'], key='mfrr_cal')

    calendars_cfg: Dict[str, pd.DataFrame] = {}
    fcr_df = normalize_calendar_df(read_calendar_df(fcr_cal_upload) or read_calendar_df(fcr_cal_path))
    if fcr_df is not None:
        calendars_cfg['FCR'] = fcr_df
    afrr_df = normalize_calendar_df(read_calendar_df(afrr_cal_upload) or read_calendar_df(afrr_cal_path))
    if afrr_df is not None:
        calendars_cfg['aFRR'] = afrr_df
    mfrr_df = normalize_calendar_df(read_calendar_df(mfrr_cal_upload) or read_calendar_df(mfrr_cal_path))
    if mfrr_df is not None:
        calendars_cfg['mFRR'] = mfrr_df

    # Sanity check: enforce power cap warning and allow auto-load battery specs from technical proposal
    try:
        enabled_products = {'FCR': fcr_enabled, 'aFRR': afrr_enabled, 'mFRR': mfrr_enabled}
        mw_allocation = {'FCR': fcr_mw, 'aFRR': afrr_mw, 'mFRR': mfrr_mw}

        # Debug: show capacity allocation
        print("\n[CAPACITY ALLOCATION DEBUG]")
        print(f"Battery power limit: {power_mw:.1f} MW")
        print(f"Battery energy capacity: {capacity_mwh:.1f} MWh")
        for product in ['FCR', 'aFRR', 'mFRR']:
            if enabled_products[product]:
                print(f"  {product}: {mw_allocation[product]:.1f} MW (enabled)")
            else:
                print(f"  {product}: {mw_allocation[product]:.1f} MW (disabled)")

        total_mw = sum([v for k, v in mw_allocation.items() if enabled_products[k]])
        print(f"Total allocated: {total_mw:.1f} MW")
        print(f"Allocation ratio: {total_mw / power_mw * 100:.1f}% of battery capacity")

        if total_mw > power_mw:
            st.warning(f"⚠️ Total allocated MW ({total_mw:.1f} MW) exceeds battery power ({power_mw:.1f} MW). Consider reducing per‑product MW or using calendars.")
            print(f"[WARNING] Over-allocation: {total_mw - power_mw:.1f} MW excess")
    except Exception as e:
        print(f"[CAPACITY ALLOCATION DEBUG] Error: {e}")

    with st.expander("Battery specs (auto from Technical Proposal)", expanded=False):
        tech_doc = find_in_data_dir([r"technical.*proposal.*mey.*energy", r"20mw.*55mwh", r"bess.*project"]) or ""
        tech_path = st.text_input("Battery spec document (PDF)", value=tech_doc)
        use_specs = st.checkbox("Use extracted specs to cap power/efficiency", value=True)
        extracted = parse_battery_specs_from_document(tech_path) if tech_path else {}
        if extracted:
            st.json(extracted)
        # Apply extracted power and efficiency if available
        cap_power_mw = power_mw
        if use_specs and extracted:
            if extracted.get('power_mw'):
                cap_power_mw = float(extracted['power_mw'])
            if extracted.get('round_trip_efficiency'):
                st.caption(f"Using extracted round-trip efficiency {extracted['round_trip_efficiency']:.2f} for activation energy scaling (informational)")
        else:
            cap_power_mw = power_mw

    sysimb_df = pd.DataFrame()
    activation_reference_map = {
        'FCR': fcr_ref_mw,
        'aFRR': afrr_ref_mw,
        'mFRR': mfrr_ref_mw,
    }
    activation_curves_map: Dict[str, pd.Series] = {}

    if sysimb_path:
        try:
            sysimb_df = load_system_imbalance_from_excel(sysimb_path)
            if sysimb_df.empty:
                st.info("System imbalance file loaded but contained no usable rows.")
        except Exception as exc:
            sysimb_df = pd.DataFrame()
            st.warning(f"Failed to load system imbalance data: {exc}")

    smoothing_flag = 'monthly' if smoothing_option == 'Monthly average' else None

    if not sysimb_df.empty:
        for prod, ref in activation_reference_map.items():
            if ref and ref > 0:
                series = compute_activation_factor_series(sysimb_df, ref, smoothing=smoothing_flag)
                if not series.empty:
                    activation_curves_map[prod] = series
        if activation_curves_map:
            st.caption("Using system imbalance history to derive activation duty factors.")

    has_imbalance_flag = not sysimb_df.empty

    if export8_path:
        try:
            imb_df = load_transelectrica_imbalance_from_excel(
                export8_path,
                fx_ron_per_eur=(1.0 if excel_currency == 'EUR' else fx_rate),
                declared_currency=excel_currency,
            )
            if not imb_df.empty and any(v.get('enabled') and v.get('mw', 0) > 0 for v in products_cfg.values()):
                src_cur = []
                if 'source_currency' in imb_df.columns:
                    src_cur = sorted({str(v) for v in imb_df['source_currency'].dropna().unique() if str(v).strip()})
                if src_cur:
                    if len(src_cur) == 1:
                        cur_label = src_cur[0]
                        st.caption(f"Detected imbalance currency: {cur_label} (internal pricing in EUR)")
                        if excel_currency.upper() != cur_label:
                            st.info(
                                f"File reports {cur_label}; the '{excel_currency}' selection was overridden during import."
                            )
                    else:
                        st.caption(
                            "Detected imbalance currencies: "
                            + ", ".join(src_cur)
                            + " (each converted to EUR before simulation)"
                        )
                price_dates_ts = pd.to_datetime(imb_df['date'], errors='coerce').dropna()

                # DATA COMPLETENESS CHECK
                if not price_dates_ts.empty:
                    date_range = (price_dates_ts.max() - price_dates_ts.min()).days + 1
                    expected_records = date_range * 96  # 96 slots per day
                    actual_records = len(imb_df)
                    completeness = actual_records / expected_records if expected_records > 0 else 0

                    # Check slots per day
                    slots_per_day = imb_df.groupby('date')['slot'].count()
                    incomplete_days = (slots_per_day < 96).sum()

                    if completeness < 0.99 or incomplete_days > 0:
                        st.warning(
                            f"⚠️ Data completeness: {completeness*100:.1f}% "
                            f"({actual_records:,}/{expected_records:,} records). "
                            f"{incomplete_days} days have <96 slots. "
                            f"This will undercount capacity revenue and activation hours."
                        )

                    # Check for frequency column
                    if 'frequency' in imb_df.columns:
                        freq_missing = imb_df['frequency'].isna().mean()
                        if freq_missing > 0.9:
                            st.info(
                                "ℹ️ Frequency column is empty. System frequency data not available for activation modeling."
                            )

                hedge_coverage = 0.0
                hedge_avg = None
                if provider.pzu_csv and not price_dates_ts.empty:
                    hedge_curve = build_hedge_price_curve(
                        provider.pzu_csv,
                        start_date=price_dates_ts.min(),
                        end_date=price_dates_ts.max(),
                        fx_ron_per_eur=fx_rate,
                    )
                    if not hedge_curve.empty:
                        imb_df = imb_df.merge(hedge_curve, on=['date', 'slot'], how='left')
                        hedge_mask = imb_df['hedge_price_eur_mwh'].notna()
                        if hedge_mask.any():
                            hedge_coverage = float(hedge_mask.mean())
                            hedge_avg = float(imb_df.loc[hedge_mask, 'hedge_price_eur_mwh'].mean())
                            st.caption(
                                f"Energy cost reference: OPCOM PZU prices applied to {hedge_coverage*100:.1f}%"
                                " of slots"
                                + (f" (avg €{hedge_avg:.1f}/MWh)" if hedge_avg is not None else "")
                            )
                        else:
                            st.info("PZU hedge curve has no overlapping slots for this period; falling back to imbalance prices for energy cost.")
                    else:
                        st.info("PZU hedge curve not available for the selected window; falling back to imbalance prices for energy cost.")

                # Threshold suggestions from percentiles
                try:
                    pos = imb_df.loc[imb_df['price_eur_mwh'] > 0, 'price_eur_mwh']
                    neg = imb_df.loc[imb_df['price_eur_mwh'] < 0, 'price_eur_mwh'].abs()
                    if len(pos) > 0 or len(neg) > 0:
                        s1, s2 = st.columns(2)
                        with s1:
                            if len(pos) > 0:
                                st.caption("Suggested up thresholds (percentiles):")
                                st.write(f"P90: €{pos.quantile(0.9):.1f} | P95: €{pos.quantile(0.95):.1f}")
                        with s2:
                            if len(neg) > 0:
                                st.caption("Suggested down thresholds (percentiles of |price|):")
                                st.write(f"P90: €{neg.quantile(0.9):.1f} | P95: €{neg.quantile(0.95):.1f}")
                except Exception:
                    pass
                price_dates = pd.to_datetime(imb_df['date'], errors='coerce').dropna().dt.normalize().unique()
                has_imbalance_flag = bool(activation_curves_map)

                # Check if DAMAS activation data is available and merge it
                damas_path = project_root / "data" / "damas_complete_fr_dataset.csv"
                use_damas = damas_path.exists()

                if use_damas:
                    try:
                        # Load DAMAS data
                        damas_df = pd.read_csv(damas_path)
                        damas_df['date'] = pd.to_datetime(damas_df['date']).dt.date.astype(str)
                        damas_df['slot'] = damas_df['slot'].astype(int)

                        # Merge DAMAS activation data with imbalance prices
                        imb_df = imb_df.merge(
                            damas_df[['date', 'slot', 'fcr_activated_mwh', 'afrr_up_activated_mwh', 'afrr_down_activated_mwh',
                                     'mfrr_up_activated_mwh', 'mfrr_down_activated_mwh', 'afrr_up_price_eur',
                                     'afrr_down_price_eur', 'mfrr_up_scheduled_price_eur', 'mfrr_down_scheduled_price_eur',
                                     'system_imbalance_mwh']],
                            on=['date', 'slot'],
                            how='left'
                        )

                        # Count how many slots have DAMAS data
                        damas_coverage = (imb_df['afrr_up_activated_mwh'].notna()).mean()
                        st.success(f"🎯 Using DAMAS activation data (90-95% accuracy) - Coverage: {damas_coverage*100:.1f}% of slots have real TSO activation volumes")

                    except Exception as e:
                        st.warning(f"⚠️ DAMAS data available but couldn't merge: {e}. Using price-based method.")
                        use_damas = False

                simm = simulate_frequency_regulation_revenue_multi(
                    imb_df,
                    products_cfg,
                    pay_down_as_positive=pay_down_positive,
                    pay_down_positive_map=paydown_map,
                    activation_factor_map=act_map,
                    calendars=calendars_cfg,
                    system_imbalance_df=sysimb_df,
                    activation_curve_map=activation_curves_map,
                    activation_price_mode=activation_price_mode,
                    pay_as_bid_map=pay_as_bid_map if activation_price_mode == 'pay_as_bid' else None,
                    battery_power_mw=cap_power_mw,
                )

                # Add data source indicator
                if use_damas:
                    simm['combined_totals']['data_source'] = 'DAMAS_ACTUAL_ACTIVATION'
                    simm['combined_totals']['expected_accuracy'] = '90-95%'
                else:
                    simm['combined_totals']['data_source'] = 'PRICE_BASED_LEGACY'
                    simm['combined_totals']['expected_accuracy'] = '±25-35%'

                st.success(f"Computed revenue for {simm['combined_totals']['months']} months of data")
                months_comb = simm['combined_monthly']
                if months_comb:
                    st.subheader("Combined Monthly Revenue (All Products)")
                    comb_df = pd.DataFrame(months_comb)
                    currency_cols = ['capacity_revenue_eur','activation_revenue_eur','total_revenue_eur']
                    float_cols = ['hours_in_data']
                    if show_raw_tables:
                        st.dataframe(comb_df, width='stretch')
                    else:
                                st.dataframe(
                                    styled_table(
                                        comb_df,
                                        currency_cols=currency_cols,
                                        float_cols=float_cols,
                                        currency_decimals=currency_decimals,
                                        float_decimals=float_decimals,
                                        thousands=thousands_sep,
                                    ),
                                    width='stretch',
                                )

                    def sum_window(months, w):
                        sub = months[-w:]
                        cap = sum(m['capacity_revenue_eur'] for m in sub)
                        act = sum(m['activation_revenue_eur'] for m in sub)
                        tot = cap + act
                        return cap, act, tot, len(sub)

                    # Use only months we actually have
                    if len(months_comb) > 0:
                        cap_all = sum(m['capacity_revenue_eur'] for m in months_comb)
                        act_all = sum(m['activation_revenue_eur'] for m in months_comb)
                        tot_all = cap_all + act_all
                        energy_cost_total = float(sum(m.get('energy_cost_eur', 0.0) for m in months_comb))
                        activation_energy_total = float(sum(m.get('activation_energy_mwh', 0.0) for m in months_comb))
                        g1, g2, g3, g4 = st.columns(4)
                        label = f"{len(months_comb)}m"
                        g1.metric(f"Capacity revenue ({label})", format_currency(cap_all, decimals=currency_decimals, thousands=thousands_sep))
                        g2.metric(f"Activation revenue ({label})", format_currency(act_all, decimals=currency_decimals, thousands=thousands_sep))
                        g3.metric(f"Total ({label})", format_currency(tot_all, decimals=currency_decimals, thousands=thousands_sep))
                        g4.metric(
                            "Energy cost (window)",
                            format_currency(energy_cost_total, decimals=currency_decimals, thousands=thousands_sep),
                        )
                        st.caption(
                            f"Activation energy ({label}) ≈ {activation_energy_total:.0f} MWh"
                        )

                        try:
                            print(
                                f"[FR DEBUG] Window {label}: cap={cap_all:.2f}€ act={act_all:.2f}€ net_energy={activation_energy_total:.2f}MWh hedge_cost={energy_cost_total:.2f}€",
                            )
                        except Exception:
                            pass

                        # Highlight when external constraints suppress activation volumes
                        enabled_products = [
                            (prod, cfg)
                            for prod, cfg in products_cfg.items()
                            if cfg.get('enabled') and cfg.get('mw', 0) > 0
                        ]
                        total_enabled_mw = sum(cfg.get('mw', 0.0) for _, cfg in enabled_products)
                        if total_enabled_mw > 0:
                            weighted_activation = sum(
                                cfg.get('mw', 0.0) * act_map.get(prod, 1.0)
                                for prod, cfg in enabled_products
                            ) / total_enabled_mw
                            hours_total = sum(m.get('hours_in_data', 0.0) for m in months_comb)
                            theoretical_energy = hours_total * total_enabled_mw * weighted_activation
                            if theoretical_energy > 0:
                                utilisation = activation_energy_total / theoretical_energy
                                if utilisation < 0.15 and has_imbalance_flag:
                                    st.info(
                                        "Activation volumes are only "
                                        f"{utilisation:.1%} of the theoretical duty factor. Check the system imbalance data "
                                        "or activation factors if you expect higher dispatch."
                                    )

                        # Annual cash flow summary (normalized to 12 months)
                        annual_debt_service = 0.0
                        recent_months = months_comb[-12:]
                        months_used = len(recent_months)
                        if months_used > 0:
                            cap_recent = sum(m['capacity_revenue_eur'] for m in recent_months)
                            act_recent = sum(m['activation_revenue_eur'] for m in recent_months)
                            energy_recent = sum(m.get('activation_energy_mwh', 0.0) for m in recent_months)
                            energy_cost_recent = sum(m.get('energy_cost_eur', 0.0) for m in recent_months)
                            total_recent = cap_recent + act_recent
                            scale_factor = 12 / months_used
                            annual_cap = cap_recent * scale_factor
                            annual_act = act_recent * scale_factor
                            annual_total = annual_cap + annual_act
                            annual_energy = energy_recent * scale_factor
                            annual_energy_cost = energy_cost_recent * scale_factor
                            annual_net = annual_total - annual_debt_service - annual_energy_cost

                            annual_table = pd.DataFrame(
                                [
                                    ("Capacity revenue (12m)", format_currency(annual_cap, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Activation revenue (12m)", format_currency(annual_act, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Total revenue (12m)", format_currency(annual_total, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Energy cost (12m)", format_currency(annual_energy_cost, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Debt service (12m)", format_currency(annual_debt_service, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Net profit (12m)", format_currency(annual_net, decimals=currency_decimals, thousands=thousands_sep)),
                                ],
                                columns=["Metric", "Value"],
                            )
                            st.subheader("FR Annual Cash Flow (normalized 12m)")
                            st.table(annual_table)
                            if months_used < 12:
                                st.caption(f"Scaled from last {months_used} month(s) of data.")

                            three_year_cap = annual_cap * 3
                            three_year_act = annual_act * 3
                            three_year_total = annual_total * 3
                            three_year_debt = annual_debt_service * 3
                            three_year_energy_cost = annual_energy_cost * 3
                            three_year_net = three_year_total - three_year_debt - three_year_energy_cost

                            outlook_table = pd.DataFrame(
                                [
                                    ("Capacity revenue (3y sim)", format_currency(three_year_cap, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Activation revenue (3y sim)", format_currency(three_year_act, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Total revenue (3y sim)", format_currency(three_year_total, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Energy cost (3y)", format_currency(three_year_energy_cost, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Debt service (3y)", format_currency(three_year_debt, decimals=currency_decimals, thousands=thousands_sep)),
                                    ("Net profit (3y sim)", format_currency(three_year_net, decimals=currency_decimals, thousands=thousands_sep)),
                                ],
                                columns=["Metric", "Value"],
                            )
                            st.subheader("FR Simulated 3-Year Outlook")
                            st.table(outlook_table)

                            try:
                                months_payload = [
                                    sanitize_session_value(dict(rec)) for rec in months_comb
                                ]
                                annual_payload = sanitize_session_value(
                                    {
                                        "capacity": float(annual_cap),
                                        "activation": float(annual_act),
                                        "total": float(annual_total),
                                        "energy": float(annual_energy),
                                        "energy_cost": float(annual_energy_cost),
                                        "debt": float(annual_debt_service),
                                        "net": float(annual_net),
                                        "source_months": int(months_used),
                                        "cost_rate": (float(annual_energy_cost) / float(annual_energy)) if annual_energy > 0 else 0.0,
                                    }
                                )
                                three_year_payload = sanitize_session_value(
                                    {
                                        "capacity": float(three_year_cap),
                                        "activation": float(three_year_act),
                                        "total": float(three_year_total),
                                        "energy_cost": float(three_year_energy_cost),
                                        "debt": float(three_year_debt),
                                        "net": float(three_year_net),
                                    }
                                )
                                new_fr_metrics = {
                                    "months": months_payload,
                                    "annual": annual_payload,
                                    "three_year": three_year_payload,
                                }
                                safe_session_state_update("fr_market_metrics", new_fr_metrics)
                            except Exception:
                                pass

                            monthly_debt_share = annual_debt_service / 12.0 if annual_debt_service else 0.0
                            monthly_rows = []
                            for rec in months_comb:
                                month_label = rec.get("month") or rec.get("month_period")
                                month_label = str(month_label)
                                cap_val = float(rec.get("capacity_revenue_eur", 0.0))
                                act_val = float(rec.get("activation_revenue_eur", 0.0))
                                tot_val = cap_val + act_val
                                energy_val = float(rec.get('activation_energy_mwh', 0.0))
                                monthly_energy_cost = float(rec.get('energy_cost_eur', 0.0))
                                net_val = tot_val - monthly_debt_share - monthly_energy_cost
                                monthly_rows.append(
                                    {
                                        "Month": month_label,
                                        "Capacity €": format_currency(cap_val, decimals=currency_decimals, thousands=thousands_sep),
                                        "Activation €": format_currency(act_val, decimals=currency_decimals, thousands=thousands_sep),
                                        "Total €": format_currency(tot_val, decimals=currency_decimals, thousands=thousands_sep),
                                        "Energy MWh": f"{energy_val:.2f}",
                                        "Energy cost €": format_currency(monthly_energy_cost, decimals=currency_decimals, thousands=thousands_sep),
                                        "Debt share €": format_currency(monthly_debt_share, decimals=currency_decimals, thousands=thousands_sep) if monthly_debt_share else "—",
                                        "Net €": format_currency(net_val, decimals=currency_decimals, thousands=thousands_sep),
                                    }
                                )

                            if monthly_rows:
                                monthly_df = pd.DataFrame(monthly_rows)
                                st.subheader("FR Monthly Cash Flow (all months)")
                                st.dataframe(monthly_df, width='stretch')
                else:
                    st.session_state.pop("fr_market_metrics", None)

                st.subheader("Per-Product Revenue")
                for prod in ['FCR', 'aFRR', 'mFRR']:
                        if not products_cfg[prod]['enabled'] or products_cfg[prod]['mw'] <= 0:
                            continue
                        st.caption(f"{prod} contracted: {products_cfg[prod]['mw']} MW @ {products_cfg[prod]['cap_eur_mw_h']} €/MW/h")
                        months_prod = simm['monthly_by_product'].get(prod, [])
                        if months_prod:
                            prod_df = pd.DataFrame(months_prod)
                            currency_cols = ['capacity_revenue_eur','activation_revenue_eur','total_revenue_eur']
                            float_cols = ['hours_in_data']
                            if show_raw_tables:
                                st.dataframe(prod_df, width='stretch')
                            else:
                                st.dataframe(
                                    styled_table(
                                        prod_df,
                                        currency_cols=currency_cols,
                                        float_cols=float_cols,
                                        currency_decimals=currency_decimals,
                                        float_decimals=float_decimals,
                                        thousands=thousands_sep,
                                    ),
                                    width='stretch',
                                )
                            totp = simm['totals_by_product'].get(prod, {})
                            p1, p2, p3 = st.columns(3)
                            p1.metric(f"{prod} Capacity total", format_currency(totp.get('capacity_revenue_eur', 0), decimals=currency_decimals, thousands=thousands_sep))
                            p2.metric(f"{prod} Activation total", format_currency(totp.get('activation_revenue_eur', 0), decimals=currency_decimals, thousands=thousands_sep))
                            p3.metric(f"{prod} Total", format_currency(totp.get('total_revenue_eur', 0), decimals=currency_decimals, thousands=thousands_sep))
                            # Diagnostics: sum of up/down slots
                            ups = sum(r.get('up_slots', 0) for r in months_prod)
                            dns = sum(r.get('down_slots', 0) for r in months_prod)
                            st.caption(f"Diagnostics: up_slots={ups}, down_slots={dns}")
            else:
                st.info("Provide a valid export-8 path and enable at least one product with MW > 0.")
        except Exception as e:
            st.error(f"Failed to read export-8 file(s): {e}")

st.set_page_config(page_title="Battery Bot - PZU & Balancing", layout="wide", page_icon="⚡")

def apply_theme() -> None:
    css_path = project_root / "assets" / "style.css"
    try:
        css = css_path.read_text(encoding="utf-8") if css_path.exists() else ""
    except Exception:
        css = ""
    st.markdown(f"<style>{css}</style>", unsafe_allow_html=True)


st.title("Battery Trading Bot - Web Interface")
apply_theme()
st.caption("Choose a view below, set config in the sidebar, then Run Strategy.")



def render_investment_financing_analysis(cfg: dict) -> None:
    """Analyse investment and financing for FR and PZU businesses independently."""

    fr_metrics = st.session_state.get("fr_market_metrics")
    pzu_metrics = st.session_state.get("pzu_market_metrics")

    if not fr_metrics or not isinstance(fr_metrics, dict) or "annual" not in fr_metrics:
        st.info("Run the FR Simulator first to capture annual metrics.")
        return
    if not pzu_metrics or not isinstance(pzu_metrics, dict) or "daily_history" not in pzu_metrics:
        st.info("Run the PZU Horizons view to compute profitability before analysing financing.")
        return

    st.subheader("💸 Investment & Financing Analysis")

    battery_cfg = cfg.get("battery", {})
    investment_cfg = cfg.get("investment", {})

    default_power = float(battery_cfg.get("power_mw", 20.0))
    default_capex_per_mw = float(investment_cfg.get("capex_per_mw", 250_000.0))
    default_additional_costs = float(investment_cfg.get("additional_costs", 0.0))
    default_equity_pct = float(investment_cfg.get("equity_percent", 30.0))
    default_interest = float(investment_cfg.get("loan_interest_percent", 6.0))
    default_term = int(investment_cfg.get("loan_term_years", 7))
    default_fr_opex = float(investment_cfg.get("fr_operating_cost_annual", 0.0))
    default_pzu_opex = float(investment_cfg.get("pzu_operating_cost_annual", 0.0))

    col_inputs = st.columns(3)
    with col_inputs[0]:
        capex_per_mw = st.number_input(
            "Capex per MW (€/MW)",
            min_value=0.0,
            value=default_capex_per_mw,
            step=50_000.0,
            help="Capital expenditure per contracted MW of power.",
        )
    with col_inputs[1]:
        project_power_mw = st.number_input(
            "Installed power (MW)",
            min_value=0.0,
            value=default_power,
            step=1.0,
            help="Total power deployed for FR/PZU strategies.",
        )
    with col_inputs[2]:
        additional_costs = st.number_input(
            "Additional fixed costs (€)",
            min_value=0.0,
            value=default_additional_costs,
            step=100_000.0,
            help="Balance of plant, integration, or other upfront costs not captured in capex per MW.",
        )

    total_investment = capex_per_mw * project_power_mw + additional_costs
    st.metric("Total investment", format_currency(total_investment, decimals=0))

    col_fin = st.columns(3)
    with col_fin[0]:
        equity_pct = st.slider(
            "Equity share (%)",
            min_value=0,
            max_value=100,
            value=int(round(default_equity_pct)),
            help="Share of each business' investment covered with equity (remainder financed with debt).",
        )
    with col_fin[1]:
        interest_rate_pct = st.number_input(
            "Loan interest (% p.a.)",
            min_value=0.0,
            max_value=30.0,
            value=default_interest,
            step=0.1,
        )
    with col_fin[2]:
        loan_term_years = int(
            st.number_input(
                "Loan term (years)",
                min_value=1,
                max_value=25,
                value=default_term,
                step=1,
            )
        )

    investment_split_pct = st.slider(
        "Investment allocated to FR (%)",
        min_value=0,
        max_value=100,
        value=50,
        step=5,
        help="Share of the total capex allocated to the FR business; the remainder is assigned to PZU trading.",
    )

    st.markdown("### Operating Cost Assumptions")
    cost_cols = st.columns(2)
    with cost_cols[0]:
        fr_operating_cost_annual = st.number_input(
            "FR operating cost (€/year)",
            min_value=0.0,
            value=default_fr_opex,
            step=25_000.0,
        )
    with cost_cols[1]:
        pzu_operating_cost_annual = st.number_input(
            "PZU operating cost (€/year)",
            min_value=0.0,
            value=default_pzu_opex,
            step=25_000.0,
        )

    equity_ratio = equity_pct / 100.0
    interest_rate = interest_rate_pct / 100.0
    fr_investment = total_investment * (investment_split_pct / 100.0)
    pzu_investment = total_investment - fr_investment
    fr_equity = fr_investment * equity_ratio
    pzu_equity = pzu_investment * equity_ratio
    fr_debt = fr_investment - fr_equity
    pzu_debt = pzu_investment - pzu_equity

    def _annuity_payment(principal: float, rate: float, periods: int) -> float:
        if principal <= 0 or periods <= 0:
            return 0.0
        if rate <= 0:
            return principal / periods
        factor = (1 + rate) ** periods
        return principal * rate * factor / (factor - 1)

    fr_annual_debt_service = _annuity_payment(fr_debt, interest_rate, loan_term_years)
    pzu_annual_debt_service = _annuity_payment(pzu_debt, interest_rate, loan_term_years)
    monthly_fr_opex = -fr_operating_cost_annual / 12.0 if fr_operating_cost_annual else 0.0
    monthly_pzu_opex = -pzu_operating_cost_annual / 12.0 if pzu_operating_cost_annual else 0.0
    monthly_fr_debt = -fr_annual_debt_service / 12.0 if fr_annual_debt_service else 0.0
    monthly_pzu_debt = -pzu_annual_debt_service / 12.0 if pzu_annual_debt_service else 0.0

    annual_fr = fr_metrics.get("annual", {})
    fr_gross_revenue = float(annual_fr.get("total", 0.0))
    fr_energy_cost = float(annual_fr.get("energy_cost", 0.0))
    fr_base_net = float(annual_fr.get("net", 0.0))
    fr_net_after_opex = fr_base_net - fr_operating_cost_annual
    fr_net_after_debt = fr_net_after_opex - fr_annual_debt_service

    daily_history_raw = pzu_metrics.get("daily_history")
    pzu_df = pd.DataFrame(daily_history_raw) if isinstance(daily_history_raw, list) and daily_history_raw else pd.DataFrame()
    pzu_base_net = 0.0
    if not pzu_df.empty and "daily_profit_eur" in pzu_df.columns:
        pzu_base_net = float(pzu_df["daily_profit_eur"].sum()) / max(len(pzu_df), 1) * 365.0
    pzu_net_after_opex = pzu_base_net - pzu_operating_cost_annual
    pzu_net_after_debt = pzu_net_after_opex - pzu_annual_debt_service

    st.markdown("### Financing Summary")
    summary_cols = st.columns(2)
    with summary_cols[0]:
        st.markdown("**Frequency Regulation (FR)**")
        st.metric("Investment", format_currency(fr_investment, decimals=0))
        st.metric("Equity", format_currency(fr_equity, decimals=0))
        st.metric("Debt principal", format_currency(fr_debt, decimals=0))
        st.metric("Annual debt service", format_currency(fr_annual_debt_service, decimals=0))
        st.metric("Net after debt", format_currency(fr_net_after_debt, decimals=0))
    with summary_cols[1]:
        st.markdown("**PZU Trading**")
        st.metric("Investment", format_currency(pzu_investment, decimals=0))
        st.metric("Equity", format_currency(pzu_equity, decimals=0))
        st.metric("Debt principal", format_currency(pzu_debt, decimals=0))
        st.metric("Annual debt service", format_currency(pzu_annual_debt_service, decimals=0))
        st.metric("Net after debt", format_currency(pzu_net_after_debt, decimals=0))

    st.markdown("### Operating Performance")
    perf_cols = st.columns(2)
    with perf_cols[0]:
        st.metric("FR revenue", format_currency(fr_gross_revenue, decimals=0))
        st.metric("FR energy cost", format_currency(fr_energy_cost, decimals=0))
        st.metric("FR operating cost", format_currency(fr_operating_cost_annual, decimals=0))
        st.metric("FR net after opex", format_currency(fr_net_after_opex, decimals=0))
    with perf_cols[1]:
        st.metric("PZU gross profit", format_currency(pzu_base_net, decimals=0))
        st.metric("PZU operating cost", format_currency(pzu_operating_cost_annual, decimals=0))
        st.metric("PZU net after opex", format_currency(pzu_net_after_opex, decimals=0))

    raw_fr_months = fr_metrics.get("months") if isinstance(fr_metrics, dict) else None
    fr_months_df = pd.DataFrame(raw_fr_months) if isinstance(raw_fr_months, list) and raw_fr_months else pd.DataFrame()

    if not fr_months_df.empty:
        if "month" in fr_months_df.columns:
            try:
                fr_months_df["month_period"] = pd.PeriodIndex(fr_months_df["month"], freq="M")
            except Exception:
                fr_months_df["month_period"] = pd.to_datetime(fr_months_df["month"], errors="coerce").dt.to_period("M")
        elif "month_period" in fr_months_df.columns:
            fr_months_df["month_period"] = pd.PeriodIndex(fr_months_df["month_period"], freq="M")
        else:
            fr_months_df["month_period"] = pd.to_datetime(fr_months_df.index, errors="coerce").to_series().dt.to_period("M")
        fr_months_df = fr_months_df.dropna(subset=["month_period"]).sort_values("month_period")

    pzu_monthly = pd.DataFrame()
    if not pzu_df.empty and "date" in pzu_df.columns:
        pzu_df["date"] = pd.to_datetime(pzu_df["date"], errors="coerce")
        pzu_df = pzu_df.dropna(subset=["date"]).sort_values("date")
        if not pzu_df.empty and "daily_profit_eur" in pzu_df.columns:
            pzu_monthly = (
                pzu_df.assign(month=pzu_df["date"].dt.to_period("M"))
                .groupby("month", as_index=False)["daily_profit_eur"]
                .sum()
                .rename(columns={"daily_profit_eur": "total_profit_eur"})
                .sort_values("month")
            )
            pzu_monthly["month_period"] = pd.PeriodIndex(pzu_monthly["month"], freq="M")

    start_candidates: List[pd.Period] = []
    end_candidates: List[pd.Period] = []
    if not fr_months_df.empty:
        start_candidates.append(fr_months_df["month_period"].min())
        end_candidates.append(fr_months_df["month_period"].max())
    if not pzu_monthly.empty:
        start_candidates.append(pzu_monthly["month_period"].min())
        end_candidates.append(pzu_monthly["month_period"].max())

    range_start = min(start_candidates) if start_candidates else None
    range_end = max(end_candidates) if end_candidates else None

    if not fr_months_df.empty:
        fr_months_df = backfill_fr_monthly_dataframe(fr_months_df, start_period=range_start, end_period=range_end)
    if not pzu_monthly.empty and range_start is not None and range_end is not None:
        monthly_index = pd.period_range(range_start, range_end, freq="M")
        pzu_monthly = pzu_monthly.set_index("month_period").reindex(monthly_index)
        pzu_monthly["total_profit_eur"] = pd.to_numeric(pzu_monthly["total_profit_eur"], errors="coerce")
        if pzu_monthly["total_profit_eur"].notna().any():
            pzu_monthly["total_profit_eur"] = pzu_monthly["total_profit_eur"].fillna(pzu_monthly["total_profit_eur"].mean())
        else:
            pzu_monthly["total_profit_eur"] = 0.0
        pzu_monthly = pzu_monthly.reset_index().rename(columns={"index": "month_period"})
        pzu_monthly["month"] = pzu_monthly["month_period"].astype(str)

    fr_months_idx = fr_months_df.set_index("month_period") if not fr_months_df.empty else pd.DataFrame()
    pzu_months_idx = pzu_monthly.set_index("month_period") if not pzu_monthly.empty else pd.DataFrame()

    all_periods: List[pd.Period] = sorted(
        set(fr_months_idx.index.to_list() if not fr_months_idx.empty else [])
        | set(pzu_months_idx.index.to_list() if not pzu_months_idx.empty else [])
    )

    def _fill_mean(series: pd.Series) -> pd.Series:
        series = pd.to_numeric(series, errors="coerce")
        if series.notna().any():
            return series.fillna(series.mean())
        return series.fillna(0.0)

    if all_periods:
        if fr_months_idx.empty:
            fr_months_idx = pd.DataFrame(index=pd.Index(all_periods, name="month_period"))
        else:
            fr_months_idx = fr_months_idx.reindex(all_periods)
        for col in ["capacity_revenue_eur", "activation_revenue_eur", "total_revenue_eur", "energy_cost_eur"]:
            if col not in fr_months_idx.columns:
                fr_months_idx[col] = np.nan
            fr_months_idx[col] = _fill_mean(fr_months_idx[col])
        if "total_revenue_eur" not in fr_months_idx.columns or fr_months_idx["total_revenue_eur"].isna().all():
            fr_months_idx["total_revenue_eur"] = fr_months_idx.get("capacity_revenue_eur", 0.0) + fr_months_idx.get("activation_revenue_eur", 0.0)
        fr_months_idx["net_before_debt"] = (
            fr_months_idx["total_revenue_eur"].fillna(0.0) - fr_months_idx["energy_cost_eur"].fillna(0.0) + monthly_fr_opex
        )

        if pzu_months_idx.empty:
            pzu_months_idx = pd.DataFrame(index=pd.Index(all_periods, name="month_period"))
        else:
            pzu_months_idx = pzu_months_idx.reindex(all_periods)
        pzu_months_idx["net_before_debt"] = _fill_mean(pzu_months_idx.get("total_profit_eur", 0.0)) + monthly_pzu_opex

    loan_term_months = loan_term_years * 12

    def build_cashflow_tables(monthly_series: pd.Series, monthly_debt_share: float, equity: float):
        rows: List[Dict[str, object]] = []
        cumulative = -equity
        rows.append(
            {
                "Period": None,
                "Month": "Initial",
                "Net before debt €": 0.0,
                "Debt service €": 0.0,
                "Net after debt €": -equity,
                "Cumulative €": cumulative,
            }
        )
        # Process historical data months
        historical_months_count = 0
        if isinstance(monthly_series, pd.Series) and not monthly_series.empty:
            monthly_series = pd.to_numeric(monthly_series, errors="coerce").fillna(0.0).sort_index()
            for idx, (period, value) in enumerate(monthly_series.items(), start=1):
                debt = monthly_debt_share if idx <= loan_term_months else 0.0
                net_after_debt = float(value) + debt
                cumulative += net_after_debt
                rows.append(
                    {
                        "Period": period,
                        "Month": str(period),
                        "Net before debt €": float(value),
                        "Debt service €": debt,
                        "Net after debt €": net_after_debt,
                        "Cumulative €": cumulative,
                    }
                )
                historical_months_count = idx

        # CRITICAL FIX: Extend debt payments beyond historical data window
        # If loan term exceeds historical period, add remaining debt-only months
        if historical_months_count < loan_term_months:
            remaining_months = loan_term_months - historical_months_count
            last_period = monthly_series.index[-1] if not monthly_series.empty else None

            for remaining_idx in range(1, remaining_months + 1):
                month_number = historical_months_count + remaining_idx
                # Project future period (approximate)
                if last_period:
                    future_period = last_period + remaining_idx
                    period_str = str(future_period)
                else:
                    period_str = f"Month {month_number}"

                # No operating revenue beyond historical data, only debt service
                debt = monthly_debt_share
                net_after_debt = debt  # Negative (debt payment only)
                cumulative += net_after_debt

                rows.append(
                    {
                        "Period": None,  # No period object for projected months
                        "Month": f"{period_str} (projected)",
                        "Net before debt €": 0.0,
                        "Debt service €": debt,
                        "Net after debt €": net_after_debt,
                        "Cumulative €": cumulative,
                    }
                )

        monthly_df = pd.DataFrame(rows)
        display_monthly = monthly_df.drop(columns=["Period"]).copy()
        for col in ["Net before debt €", "Debt service €", "Net after debt €", "Cumulative €"]:
            display_monthly[col] = display_monthly[col].apply(lambda v: format_currency(v, decimals=0))

        yearly_rows: List[Dict[str, object]] = [
            {
                "Year": 0,
                "Net before debt €": 0.0,
                "Debt service €": 0.0,
                "Net after debt €": -equity,
                "Cumulative €": -equity,
            }
        ]

        monthly_calc = monthly_df.dropna(subset=["Period"]).copy()
        if not monthly_calc.empty:
            monthly_calc["Year"] = monthly_calc["Period"].apply(lambda p: int(p.year) if isinstance(p, pd.Period) else None)
            yearly_group = (
                monthly_calc.groupby("Year")[["Net before debt €", "Debt service €", "Net after debt €"]]
                .sum()
                .reset_index()
                .sort_values("Year")
            )
            cumulative_year = -equity
            for _, row in yearly_group.iterrows():
                net_after = float(row["Net after debt €"])
                cumulative_year += net_after
                yearly_rows.append(
                    {
                        "Year": int(row["Year"]),
                        "Net before debt €": float(row["Net before debt €"]),
                        "Debt service €": float(row["Debt service €"]),
                        "Net after debt €": net_after,
                        "Cumulative €": cumulative_year,
                    }
                )

        yearly_df = pd.DataFrame(yearly_rows)
        display_yearly = yearly_df.copy()
        for col in ["Net before debt €", "Debt service €", "Net after debt €", "Cumulative €"]:
            display_yearly[col] = display_yearly[col].apply(lambda v: format_currency(v, decimals=0))

        payback_year = next((row["Year"] for row in yearly_rows if row["Year"] and row["Cumulative €"] >= 0), None)
        total_net_after_debt = sum(row["Net after debt €"] for row in yearly_rows if row["Year"])
        roi = (total_net_after_debt / equity) if equity > 0 else 0.0

        # Calculate data coverage vs loan term
        data_months = historical_months_count
        data_coverage_pct = (data_months / loan_term_months * 100) if loan_term_months > 0 else 100

        return display_monthly, display_yearly, payback_year, roi, data_coverage_pct

    fr_series = fr_months_idx["net_before_debt"] if not fr_months_idx.empty and "net_before_debt" in fr_months_idx else pd.Series(dtype=float)
    pzu_series = pzu_months_idx["net_before_debt"] if not pzu_months_idx.empty and "net_before_debt" in pzu_months_idx else pd.Series(dtype=float)

    fr_monthly_display, fr_yearly_display, fr_payback_year, fr_roi, fr_data_coverage = build_cashflow_tables(fr_series, monthly_fr_debt, fr_equity)
    pzu_monthly_display, pzu_yearly_display, pzu_payback_year, pzu_roi, pzu_data_coverage = build_cashflow_tables(pzu_series, monthly_pzu_debt, pzu_equity)

    # Warn if loan term exceeds data window
    if fr_data_coverage < 100:
        st.warning(
            f"⚠️ FR: Loan term ({loan_term_years} years) exceeds historical data period "
            f"({fr_data_coverage:.0f}% coverage). Remaining {100-fr_data_coverage:.0f}% of debt payments "
            f"projected with no operating revenue (conservative estimate)."
        )

    if pzu_data_coverage < 100:
        st.warning(
            f"⚠️ PZU: Loan term ({loan_term_years} years) exceeds historical data period "
            f"({pzu_data_coverage:.0f}% coverage). Remaining {100-pzu_data_coverage:.0f}% of debt payments "
            f"projected with no operating revenue (conservative estimate)."
        )

    st.markdown("### FR Cashflow")
    if not fr_monthly_display.empty:
        fr_view = st.radio("FR table view", ["Monthly", "Yearly"], key="fr_cashflow_view")
        if fr_view == "Monthly":
            st.dataframe(fr_monthly_display, width="stretch")
        else:
            st.dataframe(fr_yearly_display, width="stretch")
    else:
        st.info("FR monthly cashflow data unavailable; run the FR Simulator for historical periods.")

    st.markdown("### PZU Cashflow")
    if not pzu_monthly_display.empty:
        pzu_view = st.radio("PZU table view", ["Monthly", "Yearly"], key="pzu_cashflow_view")
        if pzu_view == "Monthly":
            st.dataframe(pzu_monthly_display, width="stretch")
        else:
            st.dataframe(pzu_yearly_display, width="stretch")
    else:
        st.info("PZU monthly cashflow data unavailable; run the PZU Horizons analysis for historical periods.")

    st.markdown("### Payback & ROI")
    payback_cols = st.columns(2)
    with payback_cols[0]:
        st.markdown("**FR**")
        st.metric("Payback year", "—" if fr_payback_year is None else fr_payback_year)
        st.metric("ROI", "—" if fr_equity <= 0 else f"{fr_roi * 100:.1f}%")
    with payback_cols[1]:
        st.markdown("**PZU**")
        st.metric("Payback year", "—" if pzu_payback_year is None else pzu_payback_year)
        st.metric("ROI", "—" if pzu_equity <= 0 else f"{pzu_roi * 100:.1f}%")


